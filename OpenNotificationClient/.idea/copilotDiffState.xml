<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/network/WebSocketManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/network/WebSocketManager.kt" />
              <option name="originalContent" value="package org.opennotification.opennotification_client.network&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import com.google.gson.Gson&#10;import com.google.gson.GsonBuilder&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;import okio.ByteString&#10;import org.opennotification.opennotification_client.data.models.ConnectionStatus&#10;import org.opennotification.opennotification_client.data.models.Notification&#10;import java.security.cert.X509Certificate&#10;import java.util.concurrent.ConcurrentHashMap&#10;import java.util.concurrent.TimeUnit&#10;import javax.net.ssl.SSLContext&#10;import javax.net.ssl.TrustManager&#10;import javax.net.ssl.X509TrustManager&#10;import javax.net.ssl.HostnameVerifier&#10;&#10;class WebSocketManager private constructor() {&#10;    companion object {&#10;        private const val TAG = &quot;WebSocketManager&quot;&#10;        private var BASE_WS_URL = &quot;wss://api.opennotification.org/ws&quot; // Default fallback&#10;        private const val RECONNECT_DELAY = 5000L&#10;&#10;        // SharedPreferences constants&#10;        private const val PREFS_NAME = &quot;opennotification_settings&quot;&#10;        private const val KEY_SERVER_URL = &quot;server_url&quot;&#10;        private const val DEFAULT_SERVER_URL = &quot;wss://api.opennotification.org&quot;&#10;&#10;        @Volatile&#10;        private var INSTANCE: WebSocketManager? = null&#10;&#10;        fun getInstance(): WebSocketManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = WebSocketManager()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;&#10;        // Method to initialize with context to load saved settings&#10;        fun initializeWithContext(context: Context) {&#10;            getInstance().loadServerUrlFromPreferences(context)&#10;        }&#10;    }&#10;&#10;    private val gson = GsonBuilder()&#10;        .setLenient()&#10;        .create()&#10;&#10;    // Create a trust manager that accepts all certificates for development&#10;    private val trustAllCerts = arrayOf&lt;TrustManager&gt;(object : X509TrustManager {&#10;        override fun checkClientTrusted(chain: Array&lt;out X509Certificate&gt;?, authType: String?) {}&#10;        override fun checkServerTrusted(chain: Array&lt;out X509Certificate&gt;?, authType: String?) {}&#10;        override fun getAcceptedIssuers(): Array&lt;X509Certificate&gt; = arrayOf()&#10;    })&#10;&#10;    // Create SSL context that uses our trust manager&#10;    private val sslContext = SSLContext.getInstance(&quot;SSL&quot;).apply {&#10;        init(null, trustAllCerts, java.security.SecureRandom())&#10;    }&#10;&#10;    // Create hostname verifier that accepts all hostnames for development&#10;    private val hostnameVerifier = HostnameVerifier { _, _ -&gt; true }&#10;&#10;    private val okHttpClient = OkHttpClient.Builder()&#10;        .pingInterval(30, TimeUnit.SECONDS)&#10;        .sslSocketFactory(sslContext.socketFactory, trustAllCerts[0] as X509TrustManager)&#10;        .hostnameVerifier(hostnameVerifier)&#10;        .build()&#10;&#10;    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;&#10;    // Map of GUID to WebSocket connection and status&#10;    private val connections = ConcurrentHashMap&lt;String, WebSocketConnection&gt;()&#10;&#10;    // Set to track GUIDs currently being connected to prevent duplicates&#10;    private val connectingGuids = ConcurrentHashMap.newKeySet&lt;String&gt;()&#10;&#10;    // StateFlow for connection status updates&#10;    private val _connectionStatuses = MutableStateFlow&lt;Map&lt;String, ConnectionStatus&gt;&gt;(emptyMap())&#10;    val connectionStatuses: StateFlow&lt;Map&lt;String, ConnectionStatus&gt;&gt; = _connectionStatuses&#10;&#10;    // Callback for receiving notifications&#10;    var onNotificationReceived: ((Notification) -&gt; Unit)? = null&#10;&#10;    data class WebSocketConnection(&#10;        val webSocket: WebSocket?,&#10;        val status: ConnectionStatus,&#10;        val reconnectJob: Job?&#10;    )&#10;&#10;    fun connectToGuid(guid: String) {&#10;        Log.d(TAG, &quot;Connecting to GUID: $guid&quot;)&#10;&#10;        // Check if already connected, connecting, or in the process of being connected&#10;        if (connections[guid]?.status == ConnectionStatus.CONNECTED ||&#10;            connections[guid]?.status == ConnectionStatus.CONNECTING ||&#10;            connectingGuids.contains(guid)) {&#10;            Log.d(TAG, &quot;Already connected or connecting to GUID: $guid&quot;)&#10;            return&#10;        }&#10;&#10;        // Add to connecting set to prevent duplicates&#10;        connectingGuids.add(guid)&#10;        updateConnectionStatus(guid, ConnectionStatus.CONNECTING)&#10;&#10;        // Try primary URL first&#10;        attemptConnection(guid, BASE_WS_URL, true)&#10;    }&#10;&#10;    private fun attemptConnection(guid: String, wsUrl: String, isPrimaryAttempt: Boolean) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$wsUrl/$guid&quot;)&#10;            .build()&#10;&#10;        val webSocketListener = object : WebSocketListener() {&#10;            override fun onOpen(webSocket: WebSocket, response: Response) {&#10;                Log.d(TAG, &quot;WebSocket opened for GUID: $guid using URL: $wsUrl&quot;)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;                connections[guid] = connections[guid]?.copy(&#10;                    webSocket = webSocket,&#10;                    status = ConnectionStatus.CONNECTED,&#10;                    reconnectJob = null&#10;                ) ?: WebSocketConnection(webSocket, ConnectionStatus.CONNECTED, null)&#10;                updateConnectionStatus(guid, ConnectionStatus.CONNECTED)&#10;            }&#10;&#10;            override fun onMessage(webSocket: WebSocket, text: String) {&#10;                // Check if this GUID is still in our active connections before processing&#10;                if (!connections.containsKey(guid)) {&#10;                    Log.w(TAG, &quot;Received message for disconnected GUID: $guid, ignoring message&quot;)&#10;                    return&#10;                }&#10;&#10;                Log.d(TAG, &quot;Message received for GUID $guid: $text&quot;)&#10;                try {&#10;                    val notification = gson.fromJson(text, Notification::class.java)&#10;                    onNotificationReceived?.invoke(notification)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error parsing notification: ${e.message}&quot;)&#10;                }&#10;            }&#10;&#10;            override fun onMessage(webSocket: WebSocket, bytes: ByteString) {&#10;                onMessage(webSocket, bytes.utf8())&#10;            }&#10;&#10;            override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {&#10;                Log.d(TAG, &quot;WebSocket closing for GUID: $guid, code: $code, reason: $reason&quot;)&#10;                webSocket.close(1000, null)&#10;            }&#10;&#10;            override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;                Log.d(TAG, &quot;WebSocket closed for GUID: $guid&quot;)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;                updateConnectionStatus(guid, ConnectionStatus.DISCONNECTED)&#10;                scheduleReconnect(guid)&#10;            }&#10;&#10;            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;                Log.e(TAG, &quot;WebSocket failure for GUID: $guid using URL: $wsUrl&quot;, t)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;&#10;                // Try fallback URL if this was the primary attempt and URL ends with /&#10;                if (isPrimaryAttempt &amp;&amp; wsUrl.endsWith(&quot;/&quot;)) {&#10;                    val fallbackUrl = wsUrl.removeSuffix(&quot;/&quot;)&#10;                    Log.i(TAG, &quot;Primary connection failed, trying fallback URL: $fallbackUrl&quot;)&#10;                    attemptConnection(guid, fallbackUrl, false)&#10;                    return&#10;                }&#10;&#10;                // If fallback also fails or no fallback needed, mark as error and schedule reconnect&#10;                updateConnectionStatus(guid, ConnectionStatus.ERROR)&#10;                scheduleReconnect(guid)&#10;            }&#10;        }&#10;&#10;        val webSocket = okHttpClient.newWebSocket(request, webSocketListener)&#10;        connections[guid] = WebSocketConnection(webSocket, ConnectionStatus.CONNECTING, null)&#10;    }&#10;&#10;    fun disconnectFromGuid(guid: String) {&#10;        Log.i(TAG, &quot;Disconnecting WebSocket for GUID: $guid&quot;)&#10;        connections[guid]?.let { connection -&gt;&#10;            // Cancel any pending reconnection attempts&#10;            connection.reconnectJob?.cancel()&#10;            // Close the WebSocket connection&#10;            connection.webSocket?.close(1000, &quot;Listener stopped&quot;)&#10;            Log.i(TAG, &quot;WebSocket connection closed for GUID: $guid&quot;)&#10;        }&#10;&#10;        // Remove from connections map&#10;        connections.remove(guid)&#10;        // Remove from connecting set if it was in there&#10;        connectingGuids.remove(guid)&#10;&#10;        // Immediately update connection status to disconnected and remove from tracking&#10;        val currentStatuses = _connectionStatuses.value.toMutableMap()&#10;        currentStatuses.remove(guid)&#10;        _connectionStatuses.value = currentStatuses&#10;&#10;        Log.i(TAG, &quot;WebSocket connection and status tracking removed for GUID: $guid&quot;)&#10;    }&#10;&#10;    fun disconnectAll() {&#10;        Log.d(TAG, &quot;Disconnecting all WebSocket connections&quot;)&#10;        connections.keys.forEach { guid -&gt;&#10;            disconnectFromGuid(guid)&#10;        }&#10;    }&#10;&#10;    private fun scheduleReconnect(guid: String) {&#10;        // Only schedule reconnect if the GUID is still in the connections map&#10;        // This prevents reconnecting to inactive listeners&#10;        if (!connections.containsKey(guid)) {&#10;            Log.d(TAG, &quot;Not scheduling reconnect for GUID: $guid - listener was disconnected&quot;)&#10;            return&#10;        }&#10;&#10;        val reconnectJob = scope.launch {&#10;            kotlinx.coroutines.delay(RECONNECT_DELAY)&#10;            // Double-check that the GUID is still in connections before reconnecting&#10;            // This handles the case where a listener was deactivated during the delay&#10;            if (connections.containsKey(guid)) {&#10;                Log.d(TAG, &quot;Attempting to reconnect to GUID: $guid&quot;)&#10;                connectToGuid(guid)&#10;            } else {&#10;                Log.d(TAG, &quot;Skipping reconnect for GUID: $guid - listener was deactivated&quot;)&#10;            }&#10;        }&#10;&#10;        connections[guid] = connections[guid]?.copy(reconnectJob = reconnectJob)&#10;            ?: WebSocketConnection(null, ConnectionStatus.DISCONNECTED, reconnectJob)&#10;    }&#10;&#10;    private fun updateConnectionStatus(guid: String, status: ConnectionStatus) {&#10;        Log.i(TAG, &quot;Connection status updated for GUID: $guid -&gt; $status&quot;)&#10;        val currentStatuses = _connectionStatuses.value.toMutableMap()&#10;        currentStatuses[guid] = status&#10;        _connectionStatuses.value = currentStatuses&#10;&#10;        // Log current connection summary&#10;        val totalConnections = connections.size&#10;        val activeConnections = connections.values.count { it.status == ConnectionStatus.CONNECTED }&#10;        Log.i(TAG, &quot;Connection summary: $activeConnections/$totalConnections active connections&quot;)&#10;    }&#10;&#10;    fun getConnectionStatus(guid: String): ConnectionStatus {&#10;        val status = connections[guid]?.status ?: ConnectionStatus.DISCONNECTED&#10;        Log.v(TAG, &quot;Getting connection status for GUID: $guid -&gt; $status&quot;)&#10;        return status&#10;    }&#10;&#10;    fun isConnected(guid: String): Boolean {&#10;        val isConnected = connections[guid]?.status == ConnectionStatus.CONNECTED&#10;        Log.v(TAG, &quot;Checking if GUID: $guid is connected -&gt; $isConnected&quot;)&#10;        return isConnected&#10;    }&#10;&#10;    fun getAllConnectionStatuses(): Map&lt;String, ConnectionStatus&gt; {&#10;        return connections.mapValues { it.value.status }&#10;    }&#10;&#10;    /**&#10;     * Update the WebSocket server URL and reconnect active connections&#10;     */&#10;    fun updateServerUrl(newBaseUrl: String) {&#10;        Log.i(TAG, &quot;Updating server URL from $BASE_WS_URL to $newBaseUrl&quot;)&#10;&#10;        // Disconnect all current connections&#10;        disconnectAll()&#10;&#10;        // Update the base URL&#10;        BASE_WS_URL = if (newBaseUrl.endsWith(&quot;/ws&quot;)) {&#10;            newBaseUrl&#10;        } else {&#10;            &quot;$newBaseUrl/ws&quot;&#10;        }&#10;&#10;        Log.i(TAG, &quot;Server URL updated to: $BASE_WS_URL&quot;)&#10;&#10;        // Note: Active connections will be re-established by the WebSocketService&#10;        // when it detects the disconnections&#10;    }&#10;&#10;    fun updateActiveListeners(listeners: List&lt;org.opennotification.opennotification_client.data.models.WebSocketListener&gt;) {&#10;        scope.launch {&#10;            // Get currently connected GUIDs&#10;            val currentGuids = connections.keys.toSet()&#10;&#10;            // Get GUIDs that should be active&#10;            val activeGuids = listeners.filter { it.isActive }.map { it.guid }.toSet()&#10;&#10;            Log.i(TAG, &quot;Updating active listeners:&quot;)&#10;            Log.i(TAG, &quot;  Current connections: ${currentGuids.joinToString()}&quot;)&#10;            Log.i(TAG, &quot;  Should be active: ${activeGuids.joinToString()}&quot;)&#10;&#10;            // Disconnect listeners that are no longer active or were stopped&#10;            val toDisconnect = currentGuids.minus(activeGuids)&#10;            if (toDisconnect.isNotEmpty()) {&#10;                Log.i(TAG, &quot;Disconnecting inactive listeners: ${toDisconnect.joinToString()}&quot;)&#10;                toDisconnect.forEach { guid -&gt;&#10;                    Log.i(TAG, &quot;Stopping listener for GUID: $guid - closing WebSocket connection&quot;)&#10;                    disconnectFromGuid(guid)&#10;                }&#10;            }&#10;&#10;            // Connect new active listeners&#10;            val toConnect = activeGuids.minus(currentGuids)&#10;            if (toConnect.isNotEmpty()) {&#10;                Log.i(TAG, &quot;Connecting new active listeners: ${toConnect.joinToString()}&quot;)&#10;                toConnect.forEach { guid -&gt;&#10;                    Log.i(TAG, &quot;Starting listener for GUID: $guid - establishing WebSocket connection&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;&#10;            // CRITICAL FIX: Also ensure ALL active listeners are connected, even if they appear to already be connected&#10;            // This handles the case where the service restarted and lost WebSocket connections&#10;            activeGuids.forEach { guid -&gt;&#10;                val currentConnection = connections[guid]&#10;                if (currentConnection == null || currentConnection.status != ConnectionStatus.CONNECTED) {&#10;                    Log.i(TAG, &quot;Re-establishing connection for GUID: $guid (status: ${currentConnection?.status})&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;&#10;            if (toDisconnect.isEmpty() &amp;&amp; toConnect.isEmpty()) {&#10;                Log.d(TAG, &quot;No changes needed for active listeners, but verified all connections are active&quot;)&#10;            }&#10;&#10;            Log.i(TAG, &quot;Active listeners update completed: ${activeGuids.size} active, ${toDisconnect.size} stopped, ${toConnect.size} started&quot;)&#10;        }&#10;    }&#10;&#10;    fun hasActiveConnections(): Boolean {&#10;        return connections.isNotEmpty()&#10;    }&#10;&#10;    /**&#10;     * Force reconnect all active listeners - useful for refresh functionality&#10;     */&#10;    fun forceReconnectAll() {&#10;        Log.i(TAG, &quot;Force reconnecting all active connections&quot;)&#10;        val currentConnections = connections.keys.toList()&#10;&#10;        // Disconnect all current connections but keep them in tracking&#10;        currentConnections.forEach { guid -&gt;&#10;            Log.i(TAG, &quot;Force disconnecting GUID: $guid for refresh&quot;)&#10;            connections[guid]?.let { connection -&gt;&#10;                // Cancel any pending reconnection attempts&#10;                connection.reconnectJob?.cancel()&#10;                // Close the WebSocket connection&#10;                connection.webSocket?.close(1000, &quot;Force refresh&quot;)&#10;                Log.i(TAG, &quot;WebSocket connection closed for refresh: $guid&quot;)&#10;            }&#10;&#10;            // Update status to disconnected but keep in connections map for reconnection&#10;            connections[guid] = WebSocketConnection(null, ConnectionStatus.DISCONNECTED, null)&#10;            updateConnectionStatus(guid, ConnectionStatus.DISCONNECTED)&#10;        }&#10;&#10;        // Schedule immediate reconnection for all disconnected listeners&#10;        scope.launch {&#10;            kotlinx.coroutines.delay(500) // Brief delay to ensure clean disconnection&#10;            Log.i(TAG, &quot;Starting forced reconnection for ${currentConnections.size} listeners&quot;)&#10;&#10;            currentConnections.forEach { guid -&gt;&#10;                // Only reconnect if still in connections (meaning it should be active)&#10;                if (connections.containsKey(guid)) {&#10;                    Log.i(TAG, &quot;Force reconnecting GUID: $guid&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;&#10;            Log.i(TAG, &quot;Force reconnect completed for all active listeners&quot;)&#10;        }&#10;    }&#10;    /**&#10;     * Load server URL from SharedPreferences&#10;     */&#10;    private fun loadServerUrlFromPreferences(context: Context) {&#10;        try {&#10;            val sharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            val savedUrl = sharedPreferences.getString(KEY_SERVER_URL, DEFAULT_SERVER_URL) ?: DEFAULT_SERVER_URL&#10;&#10;            // Update the base URL if it's different from default&#10;            if (savedUrl != DEFAULT_SERVER_URL) {&#10;                BASE_WS_URL = if (savedUrl.endsWith(&quot;/ws&quot;)) {&#10;                    savedUrl&#10;                } else {&#10;                    &quot;$savedUrl/ws&quot;&#10;                }&#10;                Log.i(TAG, &quot;Loaded server URL from preferences: $BASE_WS_URL&quot;)&#10;            } else {&#10;                Log.d(TAG, &quot;Using default server URL: $BASE_WS_URL&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error loading server URL from preferences, using default&quot;, e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.opennotification.opennotification_client.network&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import com.google.gson.Gson&#10;import com.google.gson.GsonBuilder&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;import okio.ByteString&#10;import org.opennotification.opennotification_client.data.models.ConnectionStatus&#10;import org.opennotification.opennotification_client.data.models.Notification&#10;import java.security.cert.X509Certificate&#10;import java.util.concurrent.ConcurrentHashMap&#10;import java.util.concurrent.TimeUnit&#10;import javax.net.ssl.SSLContext&#10;import javax.net.ssl.TrustManager&#10;import javax.net.ssl.X509TrustManager&#10;import javax.net.ssl.HostnameVerifier&#10;&#10;class WebSocketManager private constructor() {&#10;    companion object {&#10;        private const val TAG = &quot;WebSocketManager&quot;&#10;        private var BASE_WS_URL = &quot;wss://api.opennotification.org/ws&quot; // Default fallback&#10;        private const val RECONNECT_DELAY = 5000L&#10;&#10;        // SharedPreferences constants&#10;        private const val PREFS_NAME = &quot;opennotification_settings&quot;&#10;        private const val KEY_SERVER_URL = &quot;server_url&quot;&#10;        private const val DEFAULT_SERVER_URL = &quot;wss://api.opennotification.org&quot;&#10;&#10;        @Volatile&#10;        private var INSTANCE: WebSocketManager? = null&#10;&#10;        fun getInstance(): WebSocketManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = WebSocketManager()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;&#10;        // Method to initialize with context to load saved settings&#10;        fun initializeWithContext(context: Context) {&#10;            getInstance().loadServerUrlFromPreferences(context)&#10;        }&#10;    }&#10;&#10;    private val gson = GsonBuilder()&#10;        .setLenient()&#10;        .create()&#10;&#10;    // Create a trust manager that accepts all certificates for development&#10;    private val trustAllCerts = arrayOf&lt;TrustManager&gt;(object : X509TrustManager {&#10;        override fun checkClientTrusted(chain: Array&lt;out X509Certificate&gt;?, authType: String?) {}&#10;        override fun checkServerTrusted(chain: Array&lt;out X509Certificate&gt;?, authType: String?) {}&#10;        override fun getAcceptedIssuers(): Array&lt;X509Certificate&gt; = arrayOf()&#10;    })&#10;&#10;    // Create SSL context that uses our trust manager&#10;    private val sslContext = SSLContext.getInstance(&quot;SSL&quot;).apply {&#10;        init(null, trustAllCerts, java.security.SecureRandom())&#10;    }&#10;&#10;    // Create hostname verifier that accepts all hostnames for development&#10;    private val hostnameVerifier = HostnameVerifier { _, _ -&gt; true }&#10;&#10;    private val okHttpClient = OkHttpClient.Builder()&#10;        .pingInterval(30, TimeUnit.SECONDS)&#10;        .sslSocketFactory(sslContext.socketFactory, trustAllCerts[0] as X509TrustManager)&#10;        .hostnameVerifier(hostnameVerifier)&#10;        .build()&#10;&#10;    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;&#10;    // Map of GUID to WebSocket connection and status&#10;    private val connections = ConcurrentHashMap&lt;String, WebSocketConnection&gt;()&#10;&#10;    // Set to track GUIDs currently being connected to prevent duplicates&#10;    private val connectingGuids = ConcurrentHashMap.newKeySet&lt;String&gt;()&#10;&#10;    // StateFlow for connection status updates&#10;    private val _connectionStatuses = MutableStateFlow&lt;Map&lt;String, ConnectionStatus&gt;&gt;(emptyMap())&#10;    val connectionStatuses: StateFlow&lt;Map&lt;String, ConnectionStatus&gt;&gt; = _connectionStatuses&#10;&#10;    // Callback for receiving notifications&#10;    var onNotificationReceived: ((Notification) -&gt; Unit)? = null&#10;&#10;    data class WebSocketConnection(&#10;        val webSocket: WebSocket?,&#10;        val status: ConnectionStatus,&#10;        val reconnectJob: Job?&#10;    )&#10;&#10;    fun connectToGuid(guid: String) {&#10;        Log.d(TAG, &quot;Connecting to GUID: $guid&quot;)&#10;&#10;        // Check if already connected, connecting, or in the process of being connected&#10;        if (connections[guid]?.status == ConnectionStatus.CONNECTED ||&#10;            connections[guid]?.status == ConnectionStatus.CONNECTING ||&#10;            connectingGuids.contains(guid)) {&#10;            Log.d(TAG, &quot;Already connected or connecting to GUID: $guid&quot;)&#10;            return&#10;        }&#10;&#10;        // Add to connecting set to prevent duplicates&#10;        connectingGuids.add(guid)&#10;        updateConnectionStatus(guid, ConnectionStatus.CONNECTING)&#10;&#10;        // Try primary URL first&#10;        attemptConnection(guid, BASE_WS_URL, true)&#10;    }&#10;&#10;    private fun attemptConnection(guid: String, wsUrl: String, isPrimaryAttempt: Boolean) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$wsUrl/$guid&quot;)&#10;            .build()&#10;&#10;        val webSocketListener = object : WebSocketListener() {&#10;            override fun onOpen(webSocket: WebSocket, response: Response) {&#10;                Log.d(TAG, &quot;WebSocket opened for GUID: $guid using URL: $wsUrl&quot;)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;                connections[guid] = connections[guid]?.copy(&#10;                    webSocket = webSocket,&#10;                    status = ConnectionStatus.CONNECTED,&#10;                    reconnectJob = null&#10;                ) ?: WebSocketConnection(webSocket, ConnectionStatus.CONNECTED, null)&#10;                updateConnectionStatus(guid, ConnectionStatus.CONNECTED)&#10;            }&#10;&#10;            override fun onMessage(webSocket: WebSocket, text: String) {&#10;                // Check if this GUID is still in our active connections before processing&#10;                if (!connections.containsKey(guid)) {&#10;                    Log.w(TAG, &quot;Received message for disconnected GUID: $guid, ignoring message&quot;)&#10;                    return&#10;                }&#10;&#10;                Log.d(TAG, &quot;Message received for GUID $guid: $text&quot;)&#10;                try {&#10;                    val notification = gson.fromJson(text, Notification::class.java)&#10;                    onNotificationReceived?.invoke(notification)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error parsing notification: ${e.message}&quot;)&#10;                }&#10;            }&#10;&#10;            override fun onMessage(webSocket: WebSocket, bytes: ByteString) {&#10;                onMessage(webSocket, bytes.utf8())&#10;            }&#10;&#10;            override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {&#10;                Log.d(TAG, &quot;WebSocket closing for GUID: $guid, code: $code, reason: $reason&quot;)&#10;                webSocket.close(1000, null)&#10;            }&#10;&#10;            override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;                Log.d(TAG, &quot;WebSocket closed for GUID: $guid&quot;)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;                updateConnectionStatus(guid, ConnectionStatus.DISCONNECTED)&#10;                scheduleReconnect(guid)&#10;            }&#10;&#10;            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;                Log.e(TAG, &quot;WebSocket failure for GUID: $guid using URL: $wsUrl&quot;, t)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;&#10;                // Try fallback URL if this was the primary attempt and URL ends with /&#10;                if (isPrimaryAttempt &amp;&amp; wsUrl.endsWith(&quot;/&quot;)) {&#10;                    val fallbackUrl = wsUrl.removeSuffix(&quot;/&quot;)&#10;                    Log.i(TAG, &quot;Primary connection failed, trying fallback URL: $fallbackUrl&quot;)&#10;                    attemptConnection(guid, fallbackUrl, false)&#10;                    return&#10;                }&#10;&#10;                // If fallback also fails or no fallback needed, mark as error and schedule reconnect&#10;                updateConnectionStatus(guid, ConnectionStatus.ERROR)&#10;                scheduleReconnect(guid)&#10;            }&#10;        }&#10;&#10;        val webSocket = okHttpClient.newWebSocket(request, webSocketListener)&#10;        connections[guid] = WebSocketConnection(webSocket, ConnectionStatus.CONNECTING, null)&#10;    }&#10;&#10;    fun disconnectFromGuid(guid: String) {&#10;        Log.i(TAG, &quot;Disconnecting WebSocket for GUID: $guid&quot;)&#10;        connections[guid]?.let { connection -&gt;&#10;            // Cancel any pending reconnection attempts&#10;            connection.reconnectJob?.cancel()&#10;            // Close the WebSocket connection&#10;            connection.webSocket?.close(1000, &quot;Listener stopped&quot;)&#10;            Log.i(TAG, &quot;WebSocket connection closed for GUID: $guid&quot;)&#10;        }&#10;&#10;        // Remove from connections map&#10;        connections.remove(guid)&#10;        // Remove from connecting set if it was in there&#10;        connectingGuids.remove(guid)&#10;&#10;        // Immediately update connection status to disconnected and remove from tracking&#10;        val currentStatuses = _connectionStatuses.value.toMutableMap()&#10;        currentStatuses.remove(guid)&#10;        _connectionStatuses.value = currentStatuses&#10;&#10;        Log.i(TAG, &quot;WebSocket connection and status tracking removed for GUID: $guid&quot;)&#10;    }&#10;&#10;    fun disconnectAll() {&#10;        Log.d(TAG, &quot;Disconnecting all WebSocket connections&quot;)&#10;        connections.keys.forEach { guid -&gt;&#10;            disconnectFromGuid(guid)&#10;        }&#10;    }&#10;&#10;    private fun scheduleReconnect(guid: String) {&#10;        // Only schedule reconnect if the GUID is still in the connections map&#10;        // This prevents reconnecting to inactive listeners&#10;        if (!connections.containsKey(guid)) {&#10;            Log.d(TAG, &quot;Not scheduling reconnect for GUID: $guid - listener was disconnected&quot;)&#10;            return&#10;        }&#10;&#10;        val reconnectJob = scope.launch {&#10;            kotlinx.coroutines.delay(RECONNECT_DELAY)&#10;            // Double-check that the GUID is still in connections before reconnecting&#10;            // This handles the case where a listener was deactivated during the delay&#10;            if (connections.containsKey(guid)) {&#10;                Log.d(TAG, &quot;Attempting to reconnect to GUID: $guid&quot;)&#10;                connectToGuid(guid)&#10;            } else {&#10;                Log.d(TAG, &quot;Skipping reconnect for GUID: $guid - listener was deactivated&quot;)&#10;            }&#10;        }&#10;&#10;        connections[guid] = connections[guid]?.copy(reconnectJob = reconnectJob)&#10;            ?: WebSocketConnection(null, ConnectionStatus.DISCONNECTED, reconnectJob)&#10;    }&#10;&#10;    private fun updateConnectionStatus(guid: String, status: ConnectionStatus) {&#10;        Log.i(TAG, &quot;Connection status updated for GUID: $guid -&gt; $status&quot;)&#10;        val currentStatuses = _connectionStatuses.value.toMutableMap()&#10;        currentStatuses[guid] = status&#10;        _connectionStatuses.value = currentStatuses&#10;&#10;        // Log current connection summary&#10;        val totalConnections = connections.size&#10;        val activeConnections = connections.values.count { it.status == ConnectionStatus.CONNECTED }&#10;        Log.i(TAG, &quot;Connection summary: $activeConnections/$totalConnections active connections&quot;)&#10;    }&#10;&#10;    fun getConnectionStatus(guid: String): ConnectionStatus {&#10;        val status = connections[guid]?.status ?: ConnectionStatus.DISCONNECTED&#10;        Log.v(TAG, &quot;Getting connection status for GUID: $guid -&gt; $status&quot;)&#10;        return status&#10;    }&#10;&#10;    fun isConnected(guid: String): Boolean {&#10;        val isConnected = connections[guid]?.status == ConnectionStatus.CONNECTED&#10;        Log.v(TAG, &quot;Checking if GUID: $guid is connected -&gt; $isConnected&quot;)&#10;        return isConnected&#10;    }&#10;&#10;    fun getAllConnectionStatuses(): Map&lt;String, ConnectionStatus&gt; {&#10;        return connections.mapValues { it.value.status }&#10;    }&#10;&#10;    /**&#10;     * Update the WebSocket server URL and reconnect active connections&#10;     */&#10;    fun updateServerUrl(newBaseUrl: String) {&#10;        Log.i(TAG, &quot;Updating server URL from $BASE_WS_URL to $newBaseUrl&quot;)&#10;&#10;        // Store the currently active GUIDs before disconnecting&#10;        val activeGuids = connections.keys.toList()&#10;        Log.i(TAG, &quot;Preserving ${activeGuids.size} active connections for URL change&quot;)&#10;&#10;        // Disconnect all current connections but don't remove them from tracking&#10;        activeGuids.forEach { guid -&gt;&#10;            connections[guid]?.let { connection -&gt;&#10;                // Cancel any pending reconnection attempts&#10;                connection.reconnectJob?.cancel()&#10;                // Close the WebSocket connection&#10;                connection.webSocket?.close(1000, &quot;Server URL changed&quot;)&#10;                Log.i(TAG, &quot;Disconnected GUID: $guid for URL change&quot;)&#10;            }&#10;            &#10;            // Keep connection in tracking but mark as disconnected&#10;            connections[guid] = WebSocketConnection(null, ConnectionStatus.DISCONNECTED, null)&#10;            updateConnectionStatus(guid, ConnectionStatus.DISCONNECTED)&#10;        }&#10;&#10;        // Update the base URL&#10;        BASE_WS_URL = if (newBaseUrl.endsWith(&quot;/ws&quot;)) {&#10;            newBaseUrl&#10;        } else {&#10;            &quot;$newBaseUrl/ws&quot;&#10;        }&#10;&#10;        Log.i(TAG, &quot;Server URL updated to: $BASE_WS_URL&quot;)&#10;&#10;        // Immediately reconnect all previously active listeners with new URL&#10;        if (activeGuids.isNotEmpty()) {&#10;            scope.launch {&#10;                kotlinx.coroutines.delay(500) // Brief delay for clean disconnection&#10;                Log.i(TAG, &quot;Reconnecting ${activeGuids.size} listeners with new URL&quot;)&#10;                &#10;                activeGuids.forEach { guid -&gt;&#10;                    if (connections.containsKey(guid)) {&#10;                        Log.i(TAG, &quot;Reconnecting GUID: $guid to new URL&quot;)&#10;                        connectToGuid(guid)&#10;                    }&#10;                }&#10;                &#10;                Log.i(TAG, &quot;URL change reconnection completed&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateActiveListeners(listeners: List&lt;org.opennotification.opennotification_client.data.models.WebSocketListener&gt;) {&#10;        scope.launch {&#10;            // Get currently connected GUIDs&#10;            val currentGuids = connections.keys.toSet()&#10;&#10;            // Get GUIDs that should be active&#10;            val activeGuids = listeners.filter { it.isActive }.map { it.guid }.toSet()&#10;&#10;            Log.i(TAG, &quot;Updating active listeners:&quot;)&#10;            Log.i(TAG, &quot;  Current connections: ${currentGuids.joinToString()}&quot;)&#10;            Log.i(TAG, &quot;  Should be active: ${activeGuids.joinToString()}&quot;)&#10;&#10;            // Disconnect listeners that are no longer active or were stopped&#10;            val toDisconnect = currentGuids.minus(activeGuids)&#10;            if (toDisconnect.isNotEmpty()) {&#10;                Log.i(TAG, &quot;Disconnecting inactive listeners: ${toDisconnect.joinToString()}&quot;)&#10;                toDisconnect.forEach { guid -&gt;&#10;                    Log.i(TAG, &quot;Stopping listener for GUID: $guid - closing WebSocket connection&quot;)&#10;                    disconnectFromGuid(guid)&#10;                }&#10;            }&#10;&#10;            // Connect new active listeners&#10;            val toConnect = activeGuids.minus(currentGuids)&#10;            if (toConnect.isNotEmpty()) {&#10;                Log.i(TAG, &quot;Connecting new active listeners: ${toConnect.joinToString()}&quot;)&#10;                toConnect.forEach { guid -&gt;&#10;                    Log.i(TAG, &quot;Starting listener for GUID: $guid - establishing WebSocket connection&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;&#10;            // CRITICAL FIX: Also ensure ALL active listeners are connected, even if they appear to already be connected&#10;            // This handles the case where the service restarted and lost WebSocket connections&#10;            activeGuids.forEach { guid -&gt;&#10;                val currentConnection = connections[guid]&#10;                if (currentConnection == null || currentConnection.status != ConnectionStatus.CONNECTED) {&#10;                    Log.i(TAG, &quot;Re-establishing connection for GUID: $guid (status: ${currentConnection?.status})&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;&#10;            if (toDisconnect.isEmpty() &amp;&amp; toConnect.isEmpty()) {&#10;                Log.d(TAG, &quot;No changes needed for active listeners, but verified all connections are active&quot;)&#10;            }&#10;&#10;            Log.i(TAG, &quot;Active listeners update completed: ${activeGuids.size} active, ${toDisconnect.size} stopped, ${toConnect.size} started&quot;)&#10;        }&#10;    }&#10;&#10;    fun hasActiveConnections(): Boolean {&#10;        return connections.isNotEmpty()&#10;    }&#10;&#10;    /**&#10;     * Force reconnect all active listeners - useful for refresh functionality&#10;     */&#10;    fun forceReconnectAll() {&#10;        Log.i(TAG, &quot;Force reconnecting all active connections&quot;)&#10;        val currentConnections = connections.keys.toList()&#10;&#10;        // Disconnect all current connections but keep them in tracking&#10;        currentConnections.forEach { guid -&gt;&#10;            Log.i(TAG, &quot;Force disconnecting GUID: $guid for refresh&quot;)&#10;            connections[guid]?.let { connection -&gt;&#10;                // Cancel any pending reconnection attempts&#10;                connection.reconnectJob?.cancel()&#10;                // Close the WebSocket connection&#10;                connection.webSocket?.close(1000, &quot;Force refresh&quot;)&#10;                Log.i(TAG, &quot;WebSocket connection closed for refresh: $guid&quot;)&#10;            }&#10;&#10;            // Update status to disconnected but keep in connections map for reconnection&#10;            connections[guid] = WebSocketConnection(null, ConnectionStatus.DISCONNECTED, null)&#10;            updateConnectionStatus(guid, ConnectionStatus.DISCONNECTED)&#10;        }&#10;&#10;        // Schedule immediate reconnection for all disconnected listeners&#10;        scope.launch {&#10;            kotlinx.coroutines.delay(500) // Brief delay to ensure clean disconnection&#10;            Log.i(TAG, &quot;Starting forced reconnection for ${currentConnections.size} listeners&quot;)&#10;&#10;            currentConnections.forEach { guid -&gt;&#10;                // Only reconnect if still in connections (meaning it should be active)&#10;                if (connections.containsKey(guid)) {&#10;                    Log.i(TAG, &quot;Force reconnecting GUID: $guid&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;&#10;            Log.i(TAG, &quot;Force reconnect completed for all active listeners&quot;)&#10;        }&#10;    }&#10;    /**&#10;     * Load server URL from SharedPreferences&#10;     */&#10;    private fun loadServerUrlFromPreferences(context: Context) {&#10;        try {&#10;            val sharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            val savedUrl = sharedPreferences.getString(KEY_SERVER_URL, DEFAULT_SERVER_URL) ?: DEFAULT_SERVER_URL&#10;&#10;            // Update the base URL if it's different from default&#10;            if (savedUrl != DEFAULT_SERVER_URL) {&#10;                BASE_WS_URL = if (savedUrl.endsWith(&quot;/ws&quot;)) {&#10;                    savedUrl&#10;                } else {&#10;                    &quot;$savedUrl/ws&quot;&#10;                }&#10;                Log.i(TAG, &quot;Loaded server URL from preferences: $BASE_WS_URL&quot;)&#10;            } else {&#10;                Log.d(TAG, &quot;Using default server URL: $BASE_WS_URL&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error loading server URL from preferences, using default&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/viewmodel/MainViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/viewmodel/MainViewModel.kt" />
              <option name="originalContent" value="package org.opennotification.opennotification_client.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import org.opennotification.opennotification_client.data.database.AppDatabase&#10;import org.opennotification.opennotification_client.data.models.WebSocketListener&#10;import org.opennotification.opennotification_client.data.models.Notification&#10;import org.opennotification.opennotification_client.network.WebSocketManager&#10;import org.opennotification.opennotification_client.repository.NotificationRepository&#10;import org.opennotification.opennotification_client.service.WebSocketService&#10;import org.opennotification.opennotification_client.service.WatchdogService&#10;import java.util.UUID&#10;&#10;class MainViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val repository = NotificationRepository(AppDatabase.getDatabase(application))&#10;    private val webSocketManager = WebSocketManager.getInstance()&#10;&#10;    val allListeners = repository.getAllListeners()&#10;    val allNotifications = repository.getAllNotifications()&#10;    val connectionStatuses = webSocketManager.connectionStatuses&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()&#10;&#10;    private val _errorMessage = MutableStateFlow&lt;String?&gt;(null)&#10;    val errorMessage: StateFlow&lt;String?&gt; = _errorMessage.asStateFlow()&#10;&#10;    init {&#10;        // Don't start the WebSocket service automatically - only start when needed&#10;        Log.i(&quot;MainViewModel&quot;, &quot;ViewModel initialized&quot;)&#10;&#10;        // Start the watchdog service immediately - it will monitor and restart WebSocket service as needed&#10;        WatchdogService.startService(getApplication())&#10;        Log.i(&quot;MainViewModel&quot;, &quot;Watchdog service started&quot;)&#10;&#10;        // Monitor active listeners and ensure WebSocket connections&#10;        viewModelScope.launch {&#10;            allListeners.collect { listeners -&gt;&#10;                val activeListeners = listeners.filter { it.isActive }&#10;                Log.d(&quot;MainViewModel&quot;, &quot;Listeners changed: Total=${listeners.size}, Active=${activeListeners.size}&quot;)&#10;&#10;                // Only start WebSocket service if there are active listeners&#10;                if (activeListeners.isNotEmpty()) {&#10;                    Log.d(&quot;MainViewModel&quot;, &quot;Starting WebSocket service for ${activeListeners.size} active listeners&quot;)&#10;                    WebSocketService.startService(getApplication())&#10;                } else {&#10;                    Log.d(&quot;MainViewModel&quot;, &quot;No active listeners - WebSocket service will stop itself&quot;)&#10;                    // Don't explicitly stop the service here - let it stop itself when it detects no active listeners&#10;                    // This prevents race conditions and crashes&#10;                }&#10;&#10;                // Always update WebSocketManager, regardless of count&#10;                webSocketManager.updateActiveListeners(activeListeners)&#10;                Log.d(&quot;MainViewModel&quot;, &quot;Updated WebSocketManager with ${activeListeners.size} active listeners&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addNewListener(guid: String, name: String?) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                _errorMessage.value = null&#10;&#10;                // Validate GUID format&#10;                if (!isValidGuid(guid)) {&#10;                    _errorMessage.value = &quot;Invalid GUID format&quot;&#10;                    return@launch&#10;                }&#10;&#10;                // Check if listener already exists&#10;                val existingListener = repository.getListenerByGuid(guid)&#10;                if (existingListener != null) {&#10;                    _errorMessage.value = &quot;Listener for this GUID already exists&quot;&#10;                    return@launch&#10;                }&#10;&#10;                val listener = WebSocketListener(&#10;                    guid = guid,&#10;                    name = name?.takeIf { it.isNotBlank() } ?: &quot;Listener ${guid.take(8)}&quot;&#10;                )&#10;&#10;                repository.insertListener(listener)&#10;&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to add listener: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleListenerStatus(listener: WebSocketListener) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val newStatus = !listener.isActive&#10;                Log.d(&quot;MainViewModel&quot;, &quot;Toggling listener status for ${listener.guid}: ${listener.isActive} -&gt; $newStatus&quot;)&#10;&#10;                repository.updateListenerStatus(listener.id, newStatus)&#10;&#10;                Log.d(&quot;MainViewModel&quot;, &quot;Listener status updated in database for ${listener.guid}: isActive = $newStatus&quot;)&#10;&#10;                // If we're activating a listener, ensure the WebSocket service is running&#10;                if (newStatus) {&#10;                    Log.d(&quot;MainViewModel&quot;, &quot;Listener activated - starting WebSocket service&quot;)&#10;                    WebSocketService.startService(getApplication())&#10;                }&#10;&#10;                // Force refresh of active listeners&#10;                val updatedListeners = repository.getAllListeners()&#10;                Log.d(&quot;MainViewModel&quot;, &quot;Triggering WebSocket manager update after status change&quot;)&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainViewModel&quot;, &quot;Failed to update listener status for ${listener.guid}: ${e.message}&quot;, e)&#10;                _errorMessage.value = &quot;Failed to update listener status: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteListener(listener: WebSocketListener) {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.deleteListener(listener)&#10;                // Also delete associated notifications&#10;                repository.deleteNotificationsByGuid(listener.guid)&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to delete listener: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    fun renameListener(listener: WebSocketListener, newName: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedListener = listener.copy(name = newName.trim())&#10;                repository.updateListener(updatedListener)&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to rename listener: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Force refresh all connections - disconnects and reconnects all active listeners&#10;     */&#10;    fun refreshConnections() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                Log.i(&quot;MainViewModel&quot;, &quot;Refreshing all WebSocket connections&quot;)&#10;&#10;                // Force reconnect all active connections&#10;                webSocketManager.forceReconnectAll()&#10;&#10;                _errorMessage.value = null&#10;                Log.i(&quot;MainViewModel&quot;, &quot;Connection refresh initiated&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainViewModel&quot;, &quot;Error refreshing connections&quot;, e)&#10;                _errorMessage.value = &quot;Failed to refresh connections: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        _errorMessage.value = null&#10;    }&#10;&#10;    private fun isValidGuid(guid: String): Boolean {&#10;        return try {&#10;            UUID.fromString(guid)&#10;            true&#10;        } catch (e: IllegalArgumentException) {&#10;            false&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        // Stop the service when ViewModel is cleared (app is closed)&#10;        WebSocketService.stopService(getApplication())&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.opennotification.opennotification_client.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import org.opennotification.opennotification_client.data.database.AppDatabase&#10;import org.opennotification.opennotification_client.data.models.WebSocketListener&#10;import org.opennotification.opennotification_client.data.models.Notification&#10;import org.opennotification.opennotification_client.network.WebSocketManager&#10;import org.opennotification.opennotification_client.repository.NotificationRepository&#10;import org.opennotification.opennotification_client.service.WebSocketService&#10;import org.opennotification.opennotification_client.service.WatchdogService&#10;import java.util.UUID&#10;&#10;class MainViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val repository = NotificationRepository(AppDatabase.getDatabase(application))&#10;    private val webSocketManager = WebSocketManager.getInstance()&#10;&#10;    val allListeners = repository.getAllListeners()&#10;    val allNotifications = repository.getAllNotifications()&#10;    val connectionStatuses = webSocketManager.connectionStatuses&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()&#10;&#10;    private val _errorMessage = MutableStateFlow&lt;String?&gt;(null)&#10;    val errorMessage: StateFlow&lt;String?&gt; = _errorMessage.asStateFlow()&#10;&#10;    init {&#10;        // Don't start the WebSocket service automatically - only start when needed&#10;        Log.i(&quot;MainViewModel&quot;, &quot;ViewModel initialized&quot;)&#10;&#10;        // Start the watchdog service immediately - it will monitor and restart WebSocket service as needed&#10;        WatchdogService.startService(getApplication())&#10;        Log.i(&quot;MainViewModel&quot;, &quot;Watchdog service started&quot;)&#10;&#10;        // Monitor active listeners and ensure WebSocket connections&#10;        viewModelScope.launch {&#10;            allListeners.collect { listeners -&gt;&#10;                val activeListeners = listeners.filter { it.isActive }&#10;                Log.d(&quot;MainViewModel&quot;, &quot;Listeners changed: Total=${listeners.size}, Active=${activeListeners.size}&quot;)&#10;&#10;                // Only start WebSocket service if there are active listeners&#10;                if (activeListeners.isNotEmpty()) {&#10;                    Log.d(&quot;MainViewModel&quot;, &quot;Starting WebSocket service for ${activeListeners.size} active listeners&quot;)&#10;                    WebSocketService.startService(getApplication())&#10;                } else {&#10;                    Log.d(&quot;MainViewModel&quot;, &quot;No active listeners - WebSocket service will stop itself&quot;)&#10;                    // Don't explicitly stop the service here - let it stop itself when it detects no active listeners&#10;                    // This prevents race conditions and crashes&#10;                }&#10;&#10;                // Always update WebSocketManager, regardless of count&#10;                webSocketManager.updateActiveListeners(activeListeners)&#10;                Log.d(&quot;MainViewModel&quot;, &quot;Updated WebSocketManager with ${activeListeners.size} active listeners&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addNewListener(guid: String, name: String?) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                _errorMessage.value = null&#10;&#10;                // Validate GUID format&#10;                if (!isValidGuid(guid)) {&#10;                    _errorMessage.value = &quot;Invalid GUID format&quot;&#10;                    return@launch&#10;                }&#10;&#10;                // Check if listener already exists&#10;                val existingListener = repository.getListenerByGuid(guid)&#10;                if (existingListener != null) {&#10;                    _errorMessage.value = &quot;Listener for this GUID already exists&quot;&#10;                    return@launch&#10;                }&#10;&#10;                val listener = WebSocketListener(&#10;                    guid = guid,&#10;                    name = name?.takeIf { it.isNotBlank() } ?: &quot;Listener ${guid.take(8)}&quot;&#10;                )&#10;&#10;                repository.insertListener(listener)&#10;&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to add listener: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleListenerStatus(listener: WebSocketListener) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val newStatus = !listener.isActive&#10;                Log.d(&quot;MainViewModel&quot;, &quot;Toggling listener status for ${listener.guid}: ${listener.isActive} -&gt; $newStatus&quot;)&#10;&#10;                repository.updateListenerStatus(listener.id, newStatus)&#10;&#10;                Log.d(&quot;MainViewModel&quot;, &quot;Listener status updated in database for ${listener.guid}: isActive = $newStatus&quot;)&#10;&#10;                // If we're activating a listener, ensure the WebSocket service is running&#10;                if (newStatus) {&#10;                    Log.d(&quot;MainViewModel&quot;, &quot;Listener activated - starting WebSocket service&quot;)&#10;                    WebSocketService.startService(getApplication())&#10;                }&#10;&#10;                // Force refresh of active listeners&#10;                val updatedListeners = repository.getAllListeners()&#10;                Log.d(&quot;MainViewModel&quot;, &quot;Triggering WebSocket manager update after status change&quot;)&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainViewModel&quot;, &quot;Failed to update listener status for ${listener.guid}: ${e.message}&quot;, e)&#10;                _errorMessage.value = &quot;Failed to update listener status: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteListener(listener: WebSocketListener) {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.deleteListener(listener)&#10;                // Also delete associated notifications&#10;                repository.deleteNotificationsByGuid(listener.guid)&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to delete listener: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    fun renameListener(listener: WebSocketListener, newName: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedListener = listener.copy(name = newName.trim())&#10;                repository.updateListener(updatedListener)&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to rename listener: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Force refresh all connections - disconnects and reconnects all active listeners&#10;     */&#10;    fun refreshConnections() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                Log.i(&quot;MainViewModel&quot;, &quot;Refreshing all WebSocket connections&quot;)&#10;&#10;                // Force reconnect all active connections&#10;                webSocketManager.forceReconnectAll()&#10;&#10;                // Wait for the reconnection process to complete&#10;                // Give it a reasonable time to reconnect (the forceReconnectAll has a 500ms delay + connection time)&#10;                kotlinx.coroutines.delay(2000) // 2 seconds should be enough for most reconnections&#10;&#10;                _errorMessage.value = null&#10;                Log.i(&quot;MainViewModel&quot;, &quot;Connection refresh completed&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainViewModel&quot;, &quot;Error refreshing connections&quot;, e)&#10;                _errorMessage.value = &quot;Failed to refresh connections: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        _errorMessage.value = null&#10;    }&#10;&#10;    private fun isValidGuid(guid: String): Boolean {&#10;        return try {&#10;            UUID.fromString(guid)&#10;            true&#10;        } catch (e: IllegalArgumentException) {&#10;            false&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        // Stop the service when ViewModel is cleared (app is closed)&#10;        WebSocketService.stopService(getApplication())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>