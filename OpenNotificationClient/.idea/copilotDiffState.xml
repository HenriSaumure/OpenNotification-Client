<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions for network access and background service --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_DATA_SYNC&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_SPECIAL_USE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;&#10;&#10;    &lt;!-- Vibration permission for haptic feedback --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&#10;&#10;    &lt;!-- Battery optimization and background execution --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;&#10;    &lt;!-- Additional permissions for better background execution --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.USE_EXACT_ALARM&quot; /&gt;&#10;&#10;    &lt;!-- Prevent the system from stopping the app --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND&quot; /&gt;&#10;&#10;    &lt;!-- Critical permissions for background service reliability --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.START_FOREGROUND_SERVICES_FROM_BACKGROUND&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot; /&gt;&#10;&#10;    &lt;!-- Auto-start permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.QUICKBOOT_POWERON&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;com.miui.securitycenter.permission.AppPermissionsEditor&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;oppo.permission.OPPO_COMPONENT_SAFE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;com.huawei.permission.external_app_settings.USE_COMPONENT&quot; /&gt;&#10;&#10;    &lt;!-- Critical: High priority service permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.DEVICE_POWER&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.MODIFY_PHONE_STATE&quot; /&gt;&#10;&#10;    &lt;!-- Prevent process death --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.PERSISTENT_ACTIVITY&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERACT_ACROSS_USERS_FULL&quot; /&gt;&#10;&#10;    &lt;!-- Lock the app in memory --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SET_PROCESS_LIMIT&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_CONFIGURATION&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.OpenNotificationClient&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&#10;        android:requestLegacyExternalStorage=&quot;true&quot;&#10;        android:persistent=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.OpenNotificationClient&quot;&#10;            android:launchMode=&quot;singleTop&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:excludeFromRecents=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- WebSocket Background Service --&gt;&#10;        &lt;service&#10;            android:name=&quot;.service.WebSocketService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;dataSync&quot;&#10;            android:stopWithTask=&quot;false&quot;&#10;            android:directBootAware=&quot;true&quot;&#10;            android:isolatedProcess=&quot;false&quot; /&gt;&#10;&#10;        &lt;!-- Watchdog Service - monitors and restarts WebSocket service --&gt;&#10;        &lt;service&#10;            android:name=&quot;.service.WatchdogService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;specialUse&quot;&#10;            android:stopWithTask=&quot;false&quot;&#10;            android:directBootAware=&quot;true&quot;&#10;            android:isolatedProcess=&quot;false&quot;&gt;&#10;            &lt;property android:name=&quot;android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE&quot;&#10;                android:value=&quot;keep_websocket_alive&quot; /&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;!-- Boot receiver to start service on device restart --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.receiver.BootReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:directBootAware=&quot;true&quot;&gt;&#10;            &lt;intent-filter android:priority=&quot;1000&quot;&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.LOCKED_BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.QUICKBOOT_POWERON&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;data android:scheme=&quot;package&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;!-- Keep-alive receiver for battery-efficient connection monitoring --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.utils.KeepAliveReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;org.opennotification.opennotification_client.KEEP_ALIVE&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions for network access and background service --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_DATA_SYNC&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_SPECIAL_USE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;&#10;&#10;    &lt;!-- Vibration permission for haptic feedback --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&#10;&#10;    &lt;!-- Battery optimization and background execution --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;&#10;    &lt;!-- Additional permissions for better background execution --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.USE_EXACT_ALARM&quot; /&gt;&#10;&#10;    &lt;!-- Memory pressure resistance permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.KILL_BACKGROUND_PROCESSES&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REORDER_TASKS&quot; /&gt;&#10;&#10;    &lt;!-- Prevent the system from stopping the app --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND&quot; /&gt;&#10;&#10;    &lt;!-- Critical permissions for background service reliability --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.START_FOREGROUND_SERVICES_FROM_BACKGROUND&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot; /&gt;&#10;&#10;    &lt;!-- Auto-start permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.QUICKBOOT_POWERON&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;com.miui.securitycenter.permission.AppPermissionsEditor&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;oppo.permission.OPPO_COMPONENT_SAFE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;com.huawei.permission.external_app_settings.USE_COMPONENT&quot; /&gt;&#10;&#10;    &lt;!-- Critical: High priority service permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.DEVICE_POWER&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.MODIFY_PHONE_STATE&quot; /&gt;&#10;&#10;    &lt;!-- Prevent process death --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.PERSISTENT_ACTIVITY&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERACT_ACROSS_USERS_FULL&quot; /&gt;&#10;&#10;    &lt;!-- Lock the app in memory --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SET_PROCESS_LIMIT&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_CONFIGURATION&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.OpenNotificationClient&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&#10;        android:requestLegacyExternalStorage=&quot;true&quot;&#10;        android:persistent=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.OpenNotificationClient&quot;&#10;            android:launchMode=&quot;singleTop&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:excludeFromRecents=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- WebSocket Background Service --&gt;&#10;        &lt;service&#10;            android:name=&quot;.service.WebSocketService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;dataSync&quot;&#10;            android:stopWithTask=&quot;false&quot;&#10;            android:directBootAware=&quot;true&quot;&#10;            android:isolatedProcess=&quot;false&quot; /&gt;&#10;&#10;        &lt;!-- Watchdog Service - monitors and restarts WebSocket service --&gt;&#10;        &lt;service&#10;            android:name=&quot;.service.WatchdogService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;specialUse&quot;&#10;            android:stopWithTask=&quot;false&quot;&#10;            android:directBootAware=&quot;true&quot;&#10;            android:isolatedProcess=&quot;false&quot;&gt;&#10;            &lt;property android:name=&quot;android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE&quot;&#10;                android:value=&quot;keep_websocket_alive&quot; /&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;!-- Boot receiver to start service on device restart --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.receiver.BootReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:directBootAware=&quot;true&quot;&gt;&#10;            &lt;intent-filter android:priority=&quot;1000&quot;&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.LOCKED_BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.QUICKBOOT_POWERON&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;data android:scheme=&quot;package&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;!-- Keep-alive receiver for battery-efficient connection monitoring --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.utils.KeepAliveReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;org.opennotification.opennotification_client.KEEP_ALIVE&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;!-- Resurrection receiver for automatic service revival --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.utils.MemoryPressureHandler$ResurrectionReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;org.opennotification.opennotification_client.RESURRECTION&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/network/WebSocketManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/network/WebSocketManager.kt" />
              <option name="originalContent" value="package org.opennotification.opennotification_client.network&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import com.google.gson.Gson&#10;import com.google.gson.GsonBuilder&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;import okio.ByteString&#10;import org.opennotification.opennotification_client.data.models.ConnectionStatus&#10;import org.opennotification.opennotification_client.data.models.Notification&#10;import java.security.cert.X509Certificate&#10;import java.util.concurrent.ConcurrentHashMap&#10;import java.util.concurrent.TimeUnit&#10;import javax.net.ssl.SSLContext&#10;import javax.net.ssl.TrustManager&#10;import javax.net.ssl.X509TrustManager&#10;import javax.net.ssl.HostnameVerifier&#10;&#10;class WebSocketManager private constructor() {&#10;    companion object {&#10;        private const val TAG = &quot;WebSocketManager&quot;&#10;        private var BASE_WS_URL = &quot;wss://api.opennotification.org/ws&quot; // Updated default URL&#10;        private const val RECONNECT_DELAY = 5000L&#10;&#10;        // SharedPreferences constants&#10;        private const val PREFS_NAME = &quot;opennotification_settings&quot;&#10;        private const val KEY_SERVER_URL = &quot;server_url&quot;&#10;        private const val DEFAULT_SERVER_URL = &quot;https://api.opennotification.org&quot; // Updated default URL&#10;&#10;        @Volatile&#10;        private var INSTANCE: WebSocketManager? = null&#10;&#10;        fun getInstance(): WebSocketManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = WebSocketManager()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;&#10;        // Method to initialize with context to load saved settings&#10;        fun initializeWithContext(context: Context) {&#10;            getInstance().loadServerUrlFromPreferences(context)&#10;        }&#10;    }&#10;&#10;    private val gson = GsonBuilder()&#10;        .setLenient()&#10;        .create()&#10;&#10;    // Create a trust manager that accepts all certificates for development&#10;    private val trustAllCerts = arrayOf&lt;TrustManager&gt;(object : X509TrustManager {&#10;        override fun checkClientTrusted(chain: Array&lt;out X509Certificate&gt;?, authType: String?) {}&#10;        override fun checkServerTrusted(chain: Array&lt;out X509Certificate&gt;?, authType: String?) {}&#10;        override fun getAcceptedIssuers(): Array&lt;X509Certificate&gt; = arrayOf()&#10;    })&#10;&#10;    // Create SSL context that uses our trust manager&#10;    private val sslContext = SSLContext.getInstance(&quot;SSL&quot;).apply {&#10;        init(null, trustAllCerts, java.security.SecureRandom())&#10;    }&#10;&#10;    // Create hostname verifier that accepts all hostnames for development&#10;    private val hostnameVerifier = HostnameVerifier { _, _ -&gt; true }&#10;&#10;    private val okHttpClient = OkHttpClient.Builder()&#10;        .pingInterval(30, TimeUnit.SECONDS)&#10;        .sslSocketFactory(sslContext.socketFactory, trustAllCerts[0] as X509TrustManager)&#10;        .hostnameVerifier(hostnameVerifier)&#10;        .build()&#10;&#10;    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;&#10;    // Map of GUID to WebSocket connection and status&#10;    private val connections = ConcurrentHashMap&lt;String, WebSocketConnection&gt;()&#10;&#10;    // Set to track GUIDs currently being connected to prevent duplicates&#10;    private val connectingGuids = ConcurrentHashMap.newKeySet&lt;String&gt;()&#10;&#10;    // StateFlow for connection status updates&#10;    private val _connectionStatuses = MutableStateFlow&lt;Map&lt;String, ConnectionStatus&gt;&gt;(emptyMap())&#10;    val connectionStatuses: StateFlow&lt;Map&lt;String, ConnectionStatus&gt;&gt; = _connectionStatuses&#10;&#10;    // Callback for receiving notifications&#10;    var onNotificationReceived: ((Notification) -&gt; Unit)? = null&#10;&#10;    // Keep track of active listeners for automatic error retry&#10;    private val activeListenerGuids = ConcurrentHashMap.newKeySet&lt;String&gt;()&#10;&#10;    data class WebSocketConnection(&#10;        val webSocket: WebSocket?,&#10;        val status: ConnectionStatus,&#10;        val reconnectJob: Job?&#10;    )&#10;&#10;    // Battery-efficient approach: No continuous background monitoring&#10;    // Keep-alive and error retry is handled by alarm-based system&#10;&#10;    fun connectToGuid(guid: String) {&#10;        Log.d(TAG, &quot;Connecting to GUID: $guid&quot;)&#10;&#10;        // Check if already connected, connecting, or in the process of being connected&#10;        if (connections[guid]?.status == ConnectionStatus.CONNECTED ||&#10;            connections[guid]?.status == ConnectionStatus.CONNECTING ||&#10;            connectingGuids.contains(guid)) {&#10;            Log.d(TAG, &quot;Already connected or connecting to GUID: $guid&quot;)&#10;            return&#10;        }&#10;&#10;        // Add to connecting set to prevent duplicates&#10;        connectingGuids.add(guid)&#10;        updateConnectionStatus(guid, ConnectionStatus.CONNECTING)&#10;&#10;        // Try primary URL first&#10;        attemptConnection(guid, BASE_WS_URL, true)&#10;    }&#10;&#10;    private fun attemptConnection(guid: String, wsUrl: String, isPrimaryAttempt: Boolean) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$wsUrl/$guid&quot;)&#10;            .build()&#10;&#10;        val webSocketListener = object : WebSocketListener() {&#10;            override fun onOpen(webSocket: WebSocket, response: Response) {&#10;                Log.d(TAG, &quot;WebSocket opened for GUID: $guid using URL: $wsUrl&quot;)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;                connections[guid] = connections[guid]?.copy(&#10;                    webSocket = webSocket,&#10;                    status = ConnectionStatus.CONNECTED,&#10;                    reconnectJob = null&#10;                ) ?: WebSocketConnection(webSocket, ConnectionStatus.CONNECTED, null)&#10;                updateConnectionStatus(guid, ConnectionStatus.CONNECTED)&#10;            }&#10;&#10;            override fun onMessage(webSocket: WebSocket, text: String) {&#10;                // Check if this GUID is still in our active connections before processing&#10;                if (!connections.containsKey(guid)) {&#10;                    Log.w(TAG, &quot;Received message for disconnected GUID: $guid, ignoring message&quot;)&#10;                    return&#10;                }&#10;&#10;                Log.d(TAG, &quot;Message received for GUID $guid: $text&quot;)&#10;                try {&#10;                    val notification = gson.fromJson(text, Notification::class.java)&#10;                    onNotificationReceived?.invoke(notification)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error parsing notification: ${e.message}&quot;)&#10;                }&#10;            }&#10;&#10;            override fun onMessage(webSocket: WebSocket, bytes: ByteString) {&#10;                onMessage(webSocket, bytes.utf8())&#10;            }&#10;&#10;            override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {&#10;                Log.d(TAG, &quot;WebSocket closing for GUID: $guid, code: $code, reason: $reason&quot;)&#10;                webSocket.close(1000, null)&#10;            }&#10;&#10;            override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;                Log.d(TAG, &quot;WebSocket closed for GUID: $guid&quot;)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;                updateConnectionStatus(guid, ConnectionStatus.DISCONNECTED)&#10;                scheduleReconnect(guid)&#10;            }&#10;&#10;            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;                Log.e(TAG, &quot;WebSocket failure for GUID: $guid using URL: $wsUrl&quot;, t)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;&#10;                // Try fallback URL if this was the primary attempt and URL ends with /&#10;                if (isPrimaryAttempt &amp;&amp; wsUrl.endsWith(&quot;/&quot;)) {&#10;                    val fallbackUrl = wsUrl.removeSuffix(&quot;/&quot;)&#10;                    Log.i(TAG, &quot;Primary connection failed, trying fallback URL: $fallbackUrl&quot;)&#10;                    attemptConnection(guid, fallbackUrl, false)&#10;                    return&#10;                }&#10;&#10;                // If fallback also fails or no fallback needed, mark as error and schedule reconnect&#10;                updateConnectionStatus(guid, ConnectionStatus.ERROR)&#10;                scheduleReconnect(guid)&#10;            }&#10;        }&#10;&#10;        val webSocket = okHttpClient.newWebSocket(request, webSocketListener)&#10;        connections[guid] = WebSocketConnection(webSocket, ConnectionStatus.CONNECTING, null)&#10;    }&#10;&#10;    fun disconnectFromGuid(guid: String) {&#10;        Log.i(TAG, &quot;Disconnecting WebSocket for GUID: $guid&quot;)&#10;        connections[guid]?.let { connection -&gt;&#10;            // Cancel any pending reconnection attempts&#10;            connection.reconnectJob?.cancel()&#10;            // Close the WebSocket connection&#10;            connection.webSocket?.close(1000, &quot;Listener stopped&quot;)&#10;            Log.i(TAG, &quot;WebSocket connection closed for GUID: $guid&quot;)&#10;        }&#10;&#10;        // Remove from connections map&#10;        connections.remove(guid)&#10;        // Remove from connecting set if it was in there&#10;        connectingGuids.remove(guid)&#10;&#10;        // Immediately update connection status to disconnected and remove from tracking&#10;        val currentStatuses = _connectionStatuses.value.toMutableMap()&#10;        currentStatuses.remove(guid)&#10;        _connectionStatuses.value = currentStatuses&#10;&#10;        Log.i(TAG, &quot;WebSocket connection and status tracking removed for GUID: $guid&quot;)&#10;    }&#10;&#10;    fun disconnectAll() {&#10;        Log.d(TAG, &quot;Disconnecting all WebSocket connections&quot;)&#10;        connections.keys.forEach { guid -&gt;&#10;            disconnectFromGuid(guid)&#10;        }&#10;    }&#10;&#10;    private fun scheduleReconnect(guid: String) {&#10;        // Only schedule reconnect if the GUID is still in the connections map&#10;        // This prevents reconnecting to inactive listeners&#10;        if (!connections.containsKey(guid)) {&#10;            Log.d(TAG, &quot;Not scheduling reconnect for GUID: $guid - listener was disconnected&quot;)&#10;            return&#10;        }&#10;&#10;        val reconnectJob = scope.launch {&#10;            kotlinx.coroutines.delay(RECONNECT_DELAY)&#10;            // Double-check that the GUID is still in connections before reconnecting&#10;            // This handles the case where a listener was deactivated during the delay&#10;            if (connections.containsKey(guid)) {&#10;                Log.d(TAG, &quot;Attempting to reconnect to GUID: $guid&quot;)&#10;                connectToGuid(guid)&#10;            } else {&#10;                Log.d(TAG, &quot;Skipping reconnect for GUID: $guid - listener was deactivated&quot;)&#10;            }&#10;        }&#10;&#10;        connections[guid] = connections[guid]?.copy(reconnectJob = reconnectJob)&#10;            ?: WebSocketConnection(null, ConnectionStatus.DISCONNECTED, reconnectJob)&#10;    }&#10;&#10;    private fun updateConnectionStatus(guid: String, status: ConnectionStatus) {&#10;        Log.i(TAG, &quot;Connection status updated for GUID: $guid -&gt; $status&quot;)&#10;        val currentStatuses = _connectionStatuses.value.toMutableMap()&#10;        currentStatuses[guid] = status&#10;        _connectionStatuses.value = currentStatuses&#10;&#10;        // Log current connection summary&#10;        val totalConnections = connections.size&#10;        val activeConnections = connections.values.count { it.status == ConnectionStatus.CONNECTED }&#10;        Log.i(TAG, &quot;Connection summary: $activeConnections/$totalConnections active connections&quot;)&#10;    }&#10;&#10;    fun getConnectionStatus(guid: String): ConnectionStatus {&#10;        val status = connections[guid]?.status ?: ConnectionStatus.DISCONNECTED&#10;        Log.v(TAG, &quot;Getting connection status for GUID: $guid -&gt; $status&quot;)&#10;        return status&#10;    }&#10;&#10;    fun isConnected(guid: String): Boolean {&#10;        val isConnected = connections[guid]?.status == ConnectionStatus.CONNECTED&#10;        Log.v(TAG, &quot;Checking if GUID: $guid is connected -&gt; $isConnected&quot;)&#10;        return isConnected&#10;    }&#10;&#10;    fun getAllConnectionStatuses(): Map&lt;String, ConnectionStatus&gt; {&#10;        return connections.mapValues { it.value.status }&#10;    }&#10;&#10;    /**&#10;     * Update the WebSocket server URL and reconnect active connections&#10;     */&#10;    fun updateServerUrl(newBaseUrl: String) {&#10;        Log.i(TAG, &quot;Updating server URL from $BASE_WS_URL to $newBaseUrl&quot;)&#10;&#10;        // Store the currently active GUIDs before disconnecting&#10;        val activeGuids = connections.keys.toList()&#10;        Log.i(TAG, &quot;Preserving ${activeGuids.size} active connections for URL change&quot;)&#10;&#10;        // Disconnect all current connections but don't remove them from tracking&#10;        activeGuids.forEach { guid -&gt;&#10;            connections[guid]?.let { connection -&gt;&#10;                // Cancel any pending reconnection attempts&#10;                connection.reconnectJob?.cancel()&#10;                // Close the WebSocket connection&#10;                connection.webSocket?.close(1000, &quot;Server URL changed&quot;)&#10;                Log.i(TAG, &quot;Disconnected GUID: $guid for URL change&quot;)&#10;            }&#10;&#10;            // Keep connection in tracking but mark as disconnected&#10;            connections[guid] = WebSocketConnection(null, ConnectionStatus.DISCONNECTED, null)&#10;            updateConnectionStatus(guid, ConnectionStatus.DISCONNECTED)&#10;        }&#10;&#10;        // Update the base URL&#10;        BASE_WS_URL = if (newBaseUrl.endsWith(&quot;/ws&quot;)) {&#10;            newBaseUrl&#10;        } else {&#10;            &quot;$newBaseUrl/ws&quot;&#10;        }&#10;&#10;        Log.i(TAG, &quot;Server URL updated to: $BASE_WS_URL&quot;)&#10;&#10;        // Immediately reconnect all previously active listeners with new URL&#10;        if (activeGuids.isNotEmpty()) {&#10;            scope.launch {&#10;                kotlinx.coroutines.delay(500) // Brief delay for clean disconnection&#10;                Log.i(TAG, &quot;Reconnecting ${activeGuids.size} listeners with new URL&quot;)&#10;&#10;                activeGuids.forEach { guid -&gt;&#10;                    if (connections.containsKey(guid)) {&#10;                        Log.i(TAG, &quot;Reconnecting GUID: $guid to new URL&quot;)&#10;                        connectToGuid(guid)&#10;                    }&#10;                }&#10;&#10;                Log.i(TAG, &quot;URL change reconnection completed&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateActiveListeners(listeners: List&lt;org.opennotification.opennotification_client.data.models.WebSocketListener&gt;) {&#10;        scope.launch {&#10;            // Get currently connected GUIDs&#10;            val currentGuids = connections.keys.toSet()&#10;&#10;            // Get GUIDs that should be active&#10;            val activeGuids = listeners.filter { it.isActive }.map { it.guid }.toSet()&#10;&#10;            // Update the active listeners tracking for error retry monitor&#10;            activeListenerGuids.clear()&#10;            activeListenerGuids.addAll(activeGuids)&#10;&#10;            Log.i(TAG, &quot;Updating active listeners:&quot;)&#10;            Log.i(TAG, &quot;  Current connections: ${currentGuids.joinToString()}&quot;)&#10;            Log.i(TAG, &quot;  Should be active: ${activeGuids.joinToString()}&quot;)&#10;&#10;            // Disconnect listeners that are no longer active or were stopped&#10;            val toDisconnect = currentGuids.minus(activeGuids)&#10;            if (toDisconnect.isNotEmpty()) {&#10;                Log.i(TAG, &quot;Disconnecting inactive listeners: ${toDisconnect.joinToString()}&quot;)&#10;                toDisconnect.forEach { guid -&gt;&#10;                    Log.i(TAG, &quot;Stopping listener for GUID: $guid - closing WebSocket connection&quot;)&#10;                    disconnectFromGuid(guid)&#10;                }&#10;            }&#10;&#10;            // Connect new active listeners&#10;            val toConnect = activeGuids.minus(currentGuids)&#10;            if (toConnect.isNotEmpty()) {&#10;                Log.i(TAG, &quot;Connecting new active listeners: ${toConnect.joinToString()}&quot;)&#10;                toConnect.forEach { guid -&gt;&#10;                    Log.i(TAG, &quot;Starting listener for GUID: $guid - establishing WebSocket connection&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;&#10;            // CRITICAL FIX: Also ensure ALL active listeners are connected, even if they appear to already be connected&#10;            // This handles the case where the service restarted and lost WebSocket connections&#10;            activeGuids.forEach { guid -&gt;&#10;                val currentConnection = connections[guid]&#10;                if (currentConnection == null || currentConnection.status != ConnectionStatus.CONNECTED) {&#10;                    Log.i(TAG, &quot;Re-establishing connection for GUID: $guid (status: ${currentConnection?.status})&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;&#10;            if (toDisconnect.isEmpty() &amp;&amp; toConnect.isEmpty()) {&#10;                Log.d(TAG, &quot;No changes needed for active listeners, but verified all connections are active&quot;)&#10;            }&#10;&#10;            Log.i(TAG, &quot;Active listeners update completed: ${activeGuids.size} active, ${toDisconnect.size} stopped, ${toConnect.size} started&quot;)&#10;        }&#10;    }&#10;&#10;    fun hasActiveConnections(): Boolean {&#10;        return connections.isNotEmpty()&#10;    }&#10;&#10;    /**&#10;     * Send keep-alive pings to all connected WebSockets (called by alarm)&#10;     */&#10;    fun sendKeepAlivePings() {&#10;        Log.d(TAG, &quot;Sending keep-alive pings to ${connections.size} connections&quot;)&#10;&#10;        connections.forEach { (guid, connection) -&gt;&#10;            try {&#10;                if (connection.status == ConnectionStatus.CONNECTED &amp;&amp; connection.webSocket != null) {&#10;                    val pingResult = connection.webSocket.send(&quot;ping&quot;)&#10;                    if (pingResult) {&#10;                        Log.v(TAG, &quot;Keep-alive ping sent to GUID: $guid&quot;)&#10;                    } else {&#10;                        Log.w(TAG, &quot;Failed to send keep-alive ping to GUID: $guid&quot;)&#10;                        updateConnectionStatus(guid, ConnectionStatus.ERROR)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error sending keep-alive ping to GUID: $guid&quot;, e)&#10;                updateConnectionStatus(guid, ConnectionStatus.ERROR)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retry connections that are in ERROR state and should be active (called by alarm)&#10;     */&#10;    fun retryErrorConnections() {&#10;        val errorConnections = connections.filterValues { it.status == ConnectionStatus.ERROR }&#10;&#10;        if (errorConnections.isNotEmpty()) {&#10;            Log.i(TAG, &quot;Retrying ${errorConnections.size} error connections&quot;)&#10;&#10;            errorConnections.forEach { (guid, _) -&gt;&#10;                // Only retry if this GUID should still be active&#10;                if (activeListenerGuids.contains(guid)) {&#10;                    Log.i(TAG, &quot;Retrying connection for GUID with error: $guid&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get connections that are in ERROR state&#10;     */&#10;    fun getErrorConnections(): List&lt;String&gt; {&#10;        return connections.filterValues { it.status == ConnectionStatus.ERROR }.keys.toList()&#10;    }&#10;&#10;    /**&#10;     * Force reconnect all active connections - disconnects and reconnects all current connections&#10;     */&#10;    fun forceReconnectAll() {&#10;        Log.i(TAG, &quot;Force reconnecting all active connections&quot;)&#10;&#10;        // Get all current connection GUIDs&#10;        val activeGuids = connections.keys.toList()&#10;&#10;        // Disconnect all connections first&#10;        activeGuids.forEach { guid -&gt;&#10;            connections[guid]?.let { connection -&gt;&#10;                // Cancel any pending reconnection attempts&#10;                connection.reconnectJob?.cancel()&#10;                // Close the WebSocket connection&#10;                connection.webSocket?.close(1000, &quot;Force reconnect&quot;)&#10;                Log.i(TAG, &quot;WebSocket connection closed for GUID: $guid&quot;)&#10;            }&#10;&#10;            // Remove from connections map&#10;            connections.remove(guid)&#10;            // Remove from connecting set if it was in there&#10;            connectingGuids.remove(guid)&#10;&#10;            // Update status to disconnected&#10;            val currentStatuses = _connectionStatuses.value.toMutableMap()&#10;            currentStatuses.remove(guid)&#10;            _connectionStatuses.value = currentStatuses&#10;&#10;            Log.i(TAG, &quot;WebSocket connection and status tracking removed for GUID: $guid&quot;)&#10;        }&#10;&#10;        // Give a moment for disconnections to complete, then reconnect&#10;        scope.launch {&#10;            kotlinx.coroutines.delay(500) // Wait 500ms for clean disconnection&#10;&#10;            Log.i(TAG, &quot;Starting forced reconnection for ${activeGuids.size} listeners&quot;)&#10;&#10;            // Reconnect to all previously active GUIDs&#10;            activeGuids.forEach { guid -&gt;&#10;                connectToGuid(guid)&#10;            }&#10;&#10;            Log.i(TAG, &quot;Force reconnect completed for all active listeners&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load server URL from SharedPreferences&#10;     */&#10;    private fun loadServerUrlFromPreferences(context: Context) {&#10;        try {&#10;            val sharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            val savedUrl = sharedPreferences.getString(KEY_SERVER_URL, DEFAULT_SERVER_URL) ?: DEFAULT_SERVER_URL&#10;&#10;            // Update the base URL if it's different from default&#10;            if (savedUrl != DEFAULT_SERVER_URL) {&#10;                BASE_WS_URL = if (savedUrl.endsWith(&quot;/ws&quot;)) {&#10;                    savedUrl&#10;                } else {&#10;                    &quot;$savedUrl/ws&quot;&#10;                }&#10;                Log.i(TAG, &quot;Loaded server URL from preferences: $BASE_WS_URL&quot;)&#10;            } else {&#10;                Log.d(TAG, &quot;Using default server URL: $BASE_WS_URL&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error loading server URL from preferences, using default&quot;, e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.opennotification.opennotification_client.network&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import com.google.gson.Gson&#10;import com.google.gson.GsonBuilder&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;import okio.ByteString&#10;import org.opennotification.opennotification_client.data.models.ConnectionStatus&#10;import org.opennotification.opennotification_client.data.models.Notification&#10;import java.security.cert.X509Certificate&#10;import java.util.concurrent.ConcurrentHashMap&#10;import java.util.concurrent.TimeUnit&#10;import javax.net.ssl.SSLContext&#10;import javax.net.ssl.TrustManager&#10;import javax.net.ssl.X509TrustManager&#10;import javax.net.ssl.HostnameVerifier&#10;&#10;class WebSocketManager private constructor() {&#10;    companion object {&#10;        private const val TAG = &quot;WebSocketManager&quot;&#10;        private var BASE_WS_URL = &quot;wss://api.opennotification.org/ws&quot; // Updated default URL&#10;        private const val RECONNECT_DELAY = 5000L&#10;&#10;        // SharedPreferences constants&#10;        private const val PREFS_NAME = &quot;opennotification_settings&quot;&#10;        private const val KEY_SERVER_URL = &quot;server_url&quot;&#10;        private const val DEFAULT_SERVER_URL = &quot;https://api.opennotification.org&quot; // Updated default URL&#10;&#10;        @Volatile&#10;        private var INSTANCE: WebSocketManager? = null&#10;&#10;        fun getInstance(): WebSocketManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = WebSocketManager()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;&#10;        // Method to initialize with context to load saved settings&#10;        fun initializeWithContext(context: Context) {&#10;            getInstance().loadServerUrlFromPreferences(context)&#10;        }&#10;    }&#10;&#10;    private val gson = GsonBuilder()&#10;        .setLenient()&#10;        .create()&#10;&#10;    // Create a trust manager that accepts all certificates for development&#10;    private val trustAllCerts = arrayOf&lt;TrustManager&gt;(object : X509TrustManager {&#10;        override fun checkClientTrusted(chain: Array&lt;out X509Certificate&gt;?, authType: String?) {}&#10;        override fun checkServerTrusted(chain: Array&lt;out X509Certificate&gt;?, authType: String?) {}&#10;        override fun getAcceptedIssuers(): Array&lt;X509Certificate&gt; = arrayOf()&#10;    })&#10;&#10;    // Create SSL context that uses our trust manager&#10;    private val sslContext = SSLContext.getInstance(&quot;SSL&quot;).apply {&#10;        init(null, trustAllCerts, java.security.SecureRandom())&#10;    }&#10;&#10;    // Create hostname verifier that accepts all hostnames for development&#10;    private val hostnameVerifier = HostnameVerifier { _, _ -&gt; true }&#10;&#10;    private val okHttpClient = OkHttpClient.Builder()&#10;        .pingInterval(30, TimeUnit.SECONDS)&#10;        .sslSocketFactory(sslContext.socketFactory, trustAllCerts[0] as X509TrustManager)&#10;        .hostnameVerifier(hostnameVerifier)&#10;        .build()&#10;&#10;    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;&#10;    // Map of GUID to WebSocket connection and status&#10;    private val connections = ConcurrentHashMap&lt;String, WebSocketConnection&gt;()&#10;&#10;    // Set to track GUIDs currently being connected to prevent duplicates&#10;    private val connectingGuids = ConcurrentHashMap.newKeySet&lt;String&gt;()&#10;&#10;    // StateFlow for connection status updates&#10;    private val _connectionStatuses = MutableStateFlow&lt;Map&lt;String, ConnectionStatus&gt;&gt;(emptyMap())&#10;    val connectionStatuses: StateFlow&lt;Map&lt;String, ConnectionStatus&gt;&gt; = _connectionStatuses&#10;&#10;    // Callback for receiving notifications&#10;    var onNotificationReceived: ((Notification) -&gt; Unit)? = null&#10;&#10;    // Keep track of active listeners for automatic error retry&#10;    private val activeListenerGuids = ConcurrentHashMap.newKeySet&lt;String&gt;()&#10;&#10;    data class WebSocketConnection(&#10;        val webSocket: WebSocket?,&#10;        val status: ConnectionStatus,&#10;        val reconnectJob: Job?&#10;    )&#10;&#10;    // Battery-efficient approach: No continuous background monitoring&#10;    // Keep-alive and error retry is handled by alarm-based system&#10;&#10;    fun connectToGuid(guid: String) {&#10;        Log.d(TAG, &quot;Connecting to GUID: $guid&quot;)&#10;&#10;        // Check if already connected or currently connecting&#10;        val currentConnection = connections[guid]&#10;        if (currentConnection?.status == ConnectionStatus.CONNECTED) {&#10;            Log.d(TAG, &quot;Already connected to GUID: $guid&quot;)&#10;            return&#10;        }&#10;&#10;        // If connecting but it's been too long, allow reconnection attempt&#10;        if (currentConnection?.status == ConnectionStatus.CONNECTING) {&#10;            Log.d(TAG, &quot;Connection already in progress for GUID: $guid&quot;)&#10;            return&#10;        }&#10;&#10;        // If in connecting set, remove it to allow fresh connection attempt&#10;        if (connectingGuids.contains(guid)) {&#10;            Log.w(TAG, &quot;Removing stale connecting state for GUID: $guid&quot;)&#10;            connectingGuids.remove(guid)&#10;        }&#10;&#10;        // Cancel any existing reconnect job before starting new connection&#10;        currentConnection?.reconnectJob?.cancel()&#10;&#10;        // Add to connecting set to prevent duplicates&#10;        connectingGuids.add(guid)&#10;        updateConnectionStatus(guid, ConnectionStatus.CONNECTING)&#10;&#10;        // Try primary URL first&#10;        attemptConnection(guid, BASE_WS_URL, true)&#10;    }&#10;&#10;    private fun attemptConnection(guid: String, wsUrl: String, isPrimaryAttempt: Boolean) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$wsUrl/$guid&quot;)&#10;            .build()&#10;&#10;        val webSocketListener = object : WebSocketListener() {&#10;            override fun onOpen(webSocket: WebSocket, response: Response) {&#10;                Log.d(TAG, &quot;WebSocket opened for GUID: $guid using URL: $wsUrl&quot;)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;                connections[guid] = connections[guid]?.copy(&#10;                    webSocket = webSocket,&#10;                    status = ConnectionStatus.CONNECTED,&#10;                    reconnectJob = null&#10;                ) ?: WebSocketConnection(webSocket, ConnectionStatus.CONNECTED, null)&#10;                updateConnectionStatus(guid, ConnectionStatus.CONNECTED)&#10;            }&#10;&#10;            override fun onMessage(webSocket: WebSocket, text: String) {&#10;                // Check if this GUID is still in our active connections before processing&#10;                if (!connections.containsKey(guid)) {&#10;                    Log.w(TAG, &quot;Received message for disconnected GUID: $guid, ignoring message&quot;)&#10;                    return&#10;                }&#10;&#10;                Log.d(TAG, &quot;Message received for GUID $guid: $text&quot;)&#10;                try {&#10;                    val notification = gson.fromJson(text, Notification::class.java)&#10;                    onNotificationReceived?.invoke(notification)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error parsing notification: ${e.message}&quot;)&#10;                }&#10;            }&#10;&#10;            override fun onMessage(webSocket: WebSocket, bytes: ByteString) {&#10;                onMessage(webSocket, bytes.utf8())&#10;            }&#10;&#10;            override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {&#10;                Log.d(TAG, &quot;WebSocket closing for GUID: $guid, code: $code, reason: $reason&quot;)&#10;                webSocket.close(1000, null)&#10;            }&#10;&#10;            override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;                Log.d(TAG, &quot;WebSocket closed for GUID: $guid&quot;)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;                updateConnectionStatus(guid, ConnectionStatus.DISCONNECTED)&#10;                scheduleReconnect(guid)&#10;            }&#10;&#10;            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;                Log.e(TAG, &quot;WebSocket failure for GUID: $guid using URL: $wsUrl&quot;, t)&#10;                connectingGuids.remove(guid) // Remove from connecting set&#10;&#10;                // Try fallback URL if this was the primary attempt and URL ends with /&#10;                if (isPrimaryAttempt &amp;&amp; wsUrl.endsWith(&quot;/&quot;)) {&#10;                    val fallbackUrl = wsUrl.removeSuffix(&quot;/&quot;)&#10;                    Log.i(TAG, &quot;Primary connection failed, trying fallback URL: $fallbackUrl&quot;)&#10;                    attemptConnection(guid, fallbackUrl, false)&#10;                    return&#10;                }&#10;&#10;                // If fallback also fails or no fallback needed, mark as error and schedule reconnect&#10;                updateConnectionStatus(guid, ConnectionStatus.ERROR)&#10;                scheduleReconnect(guid)&#10;            }&#10;        }&#10;&#10;        val webSocket = okHttpClient.newWebSocket(request, webSocketListener)&#10;        connections[guid] = WebSocketConnection(webSocket, ConnectionStatus.CONNECTING, null)&#10;    }&#10;&#10;    fun disconnectFromGuid(guid: String) {&#10;        Log.i(TAG, &quot;Disconnecting WebSocket for GUID: $guid&quot;)&#10;        connections[guid]?.let { connection -&gt;&#10;            // Cancel any pending reconnection attempts&#10;            connection.reconnectJob?.cancel()&#10;            // Close the WebSocket connection&#10;            connection.webSocket?.close(1000, &quot;Listener stopped&quot;)&#10;            Log.i(TAG, &quot;WebSocket connection closed for GUID: $guid&quot;)&#10;        }&#10;&#10;        // Remove from connections map&#10;        connections.remove(guid)&#10;        // Remove from connecting set if it was in there&#10;        connectingGuids.remove(guid)&#10;&#10;        // Immediately update connection status to disconnected and remove from tracking&#10;        val currentStatuses = _connectionStatuses.value.toMutableMap()&#10;        currentStatuses.remove(guid)&#10;        _connectionStatuses.value = currentStatuses&#10;&#10;        Log.i(TAG, &quot;WebSocket connection and status tracking removed for GUID: $guid&quot;)&#10;    }&#10;&#10;    fun disconnectAll() {&#10;        Log.d(TAG, &quot;Disconnecting all WebSocket connections&quot;)&#10;        connections.keys.forEach { guid -&gt;&#10;            disconnectFromGuid(guid)&#10;        }&#10;    }&#10;&#10;    private fun scheduleReconnect(guid: String) {&#10;        // Only schedule reconnect if the GUID is still in the connections map&#10;        // This prevents reconnecting to inactive listeners&#10;        if (!connections.containsKey(guid)) {&#10;            Log.d(TAG, &quot;Not scheduling reconnect for GUID: $guid - listener was disconnected&quot;)&#10;            return&#10;        }&#10;&#10;        val reconnectJob = scope.launch {&#10;            kotlinx.coroutines.delay(RECONNECT_DELAY)&#10;            // Double-check that the GUID is still in connections before reconnecting&#10;            // This handles the case where a listener was deactivated during the delay&#10;            if (connections.containsKey(guid)) {&#10;                Log.d(TAG, &quot;Attempting to reconnect to GUID: $guid&quot;)&#10;                connectToGuid(guid)&#10;            } else {&#10;                Log.d(TAG, &quot;Skipping reconnect for GUID: $guid - listener was deactivated&quot;)&#10;            }&#10;        }&#10;&#10;        connections[guid] = connections[guid]?.copy(reconnectJob = reconnectJob)&#10;            ?: WebSocketConnection(null, ConnectionStatus.DISCONNECTED, reconnectJob)&#10;    }&#10;&#10;    private fun updateConnectionStatus(guid: String, status: ConnectionStatus) {&#10;        Log.i(TAG, &quot;Connection status updated for GUID: $guid -&gt; $status&quot;)&#10;        val currentStatuses = _connectionStatuses.value.toMutableMap()&#10;        currentStatuses[guid] = status&#10;        _connectionStatuses.value = currentStatuses&#10;&#10;        // Log current connection summary&#10;        val totalConnections = connections.size&#10;        val activeConnections = connections.values.count { it.status == ConnectionStatus.CONNECTED }&#10;        Log.i(TAG, &quot;Connection summary: $activeConnections/$totalConnections active connections&quot;)&#10;    }&#10;&#10;    fun getConnectionStatus(guid: String): ConnectionStatus {&#10;        val status = connections[guid]?.status ?: ConnectionStatus.DISCONNECTED&#10;        Log.v(TAG, &quot;Getting connection status for GUID: $guid -&gt; $status&quot;)&#10;        return status&#10;    }&#10;&#10;    fun isConnected(guid: String): Boolean {&#10;        val isConnected = connections[guid]?.status == ConnectionStatus.CONNECTED&#10;        Log.v(TAG, &quot;Checking if GUID: $guid is connected -&gt; $isConnected&quot;)&#10;        return isConnected&#10;    }&#10;&#10;    fun getAllConnectionStatuses(): Map&lt;String, ConnectionStatus&gt; {&#10;        return connections.mapValues { it.value.status }&#10;    }&#10;&#10;    /**&#10;     * Update the WebSocket server URL and reconnect active connections&#10;     */&#10;    fun updateServerUrl(newBaseUrl: String) {&#10;        Log.i(TAG, &quot;Updating server URL from $BASE_WS_URL to $newBaseUrl&quot;)&#10;&#10;        // Store the currently active GUIDs before disconnecting&#10;        val activeGuids = connections.keys.toList()&#10;        Log.i(TAG, &quot;Preserving ${activeGuids.size} active connections for URL change&quot;)&#10;&#10;        // Disconnect all current connections but don't remove them from tracking&#10;        activeGuids.forEach { guid -&gt;&#10;            connections[guid]?.let { connection -&gt;&#10;                // Cancel any pending reconnection attempts&#10;                connection.reconnectJob?.cancel()&#10;                // Close the WebSocket connection&#10;                connection.webSocket?.close(1000, &quot;Server URL changed&quot;)&#10;                Log.i(TAG, &quot;Disconnected GUID: $guid for URL change&quot;)&#10;            }&#10;&#10;            // Keep connection in tracking but mark as disconnected&#10;            connections[guid] = WebSocketConnection(null, ConnectionStatus.DISCONNECTED, null)&#10;            updateConnectionStatus(guid, ConnectionStatus.DISCONNECTED)&#10;        }&#10;&#10;        // Update the base URL&#10;        BASE_WS_URL = if (newBaseUrl.endsWith(&quot;/ws&quot;)) {&#10;            newBaseUrl&#10;        } else {&#10;            &quot;$newBaseUrl/ws&quot;&#10;        }&#10;&#10;        Log.i(TAG, &quot;Server URL updated to: $BASE_WS_URL&quot;)&#10;&#10;        // Immediately reconnect all previously active listeners with new URL&#10;        if (activeGuids.isNotEmpty()) {&#10;            scope.launch {&#10;                kotlinx.coroutines.delay(500) // Brief delay for clean disconnection&#10;                Log.i(TAG, &quot;Reconnecting ${activeGuids.size} listeners with new URL&quot;)&#10;&#10;                activeGuids.forEach { guid -&gt;&#10;                    if (connections.containsKey(guid)) {&#10;                        Log.i(TAG, &quot;Reconnecting GUID: $guid to new URL&quot;)&#10;                        connectToGuid(guid)&#10;                    }&#10;                }&#10;&#10;                Log.i(TAG, &quot;URL change reconnection completed&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateActiveListeners(listeners: List&lt;org.opennotification.opennotification_client.data.models.WebSocketListener&gt;) {&#10;        scope.launch {&#10;            // Get currently connected GUIDs&#10;            val currentGuids = connections.keys.toSet()&#10;&#10;            // Get GUIDs that should be active&#10;            val activeGuids = listeners.filter { it.isActive }.map { it.guid }.toSet()&#10;&#10;            // Update the active listeners tracking for error retry monitor&#10;            activeListenerGuids.clear()&#10;            activeListenerGuids.addAll(activeGuids)&#10;&#10;            Log.i(TAG, &quot;Updating active listeners:&quot;)&#10;            Log.i(TAG, &quot;  Current connections: ${currentGuids.joinToString()}&quot;)&#10;            Log.i(TAG, &quot;  Should be active: ${activeGuids.joinToString()}&quot;)&#10;&#10;            // Disconnect listeners that are no longer active or were stopped&#10;            val toDisconnect = currentGuids.minus(activeGuids)&#10;            if (toDisconnect.isNotEmpty()) {&#10;                Log.i(TAG, &quot;Disconnecting inactive listeners: ${toDisconnect.joinToString()}&quot;)&#10;                toDisconnect.forEach { guid -&gt;&#10;                    Log.i(TAG, &quot;Stopping listener for GUID: $guid - closing WebSocket connection&quot;)&#10;                    disconnectFromGuid(guid)&#10;                }&#10;            }&#10;&#10;            // Connect new active listeners&#10;            val toConnect = activeGuids.minus(currentGuids)&#10;            if (toConnect.isNotEmpty()) {&#10;                Log.i(TAG, &quot;Connecting new active listeners: ${toConnect.joinToString()}&quot;)&#10;                toConnect.forEach { guid -&gt;&#10;                    Log.i(TAG, &quot;Starting listener for GUID: $guid - establishing WebSocket connection&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;&#10;            // CRITICAL FIX: Also ensure ALL active listeners are connected, even if they appear to already be connected&#10;            // This handles the case where the service restarted and lost WebSocket connections&#10;            activeGuids.forEach { guid -&gt;&#10;                val currentConnection = connections[guid]&#10;                if (currentConnection == null || currentConnection.status != ConnectionStatus.CONNECTED) {&#10;                    Log.i(TAG, &quot;Re-establishing connection for GUID: $guid (status: ${currentConnection?.status})&quot;)&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;&#10;            if (toDisconnect.isEmpty() &amp;&amp; toConnect.isEmpty()) {&#10;                Log.d(TAG, &quot;No changes needed for active listeners, but verified all connections are active&quot;)&#10;            }&#10;&#10;            Log.i(TAG, &quot;Active listeners update completed: ${activeGuids.size} active, ${toDisconnect.size} stopped, ${toConnect.size} started&quot;)&#10;        }&#10;    }&#10;&#10;    fun hasActiveConnections(): Boolean {&#10;        return connections.isNotEmpty()&#10;    }&#10;&#10;    /**&#10;     * Send keep-alive pings to all connected WebSockets (called by alarm)&#10;     */&#10;    fun sendKeepAlivePings() {&#10;        Log.d(TAG, &quot;Sending keep-alive pings to ${connections.size} connections&quot;)&#10;&#10;        connections.forEach { (guid, connection) -&gt;&#10;            try {&#10;                if (connection.status == ConnectionStatus.CONNECTED &amp;&amp; connection.webSocket != null) {&#10;                    val pingResult = connection.webSocket.send(&quot;ping&quot;)&#10;                    if (pingResult) {&#10;                        Log.v(TAG, &quot;Keep-alive ping sent to GUID: $guid&quot;)&#10;                    } else {&#10;                        Log.w(TAG, &quot;Failed to send keep-alive ping to GUID: $guid&quot;)&#10;                        updateConnectionStatus(guid, ConnectionStatus.ERROR)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error sending keep-alive ping to GUID: $guid&quot;, e)&#10;                updateConnectionStatus(guid, ConnectionStatus.ERROR)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retry connections that are in ERROR state and should be active (called by alarm)&#10;     */&#10;    fun retryErrorConnections() {&#10;        val errorConnections = connections.filterValues { it.status == ConnectionStatus.ERROR }&#10;&#10;        if (errorConnections.isNotEmpty()) {&#10;            Log.i(TAG, &quot;Retrying ${errorConnections.size} error connections&quot;)&#10;&#10;            errorConnections.forEach { (guid, connection) -&gt;&#10;                // Only retry if this GUID should still be active&#10;                if (activeListenerGuids.contains(guid)) {&#10;                    Log.i(TAG, &quot;Forcing fresh connection attempt for error GUID: $guid&quot;)&#10;                    &#10;                    // Cancel any existing reconnect job&#10;                    connection.reconnectJob?.cancel()&#10;                    &#10;                    // Remove from connecting set to allow fresh attempt&#10;                    connectingGuids.remove(guid)&#10;                    &#10;                    // Close any existing WebSocket connection&#10;                    connection.webSocket?.close(1000, &quot;Error retry&quot;)&#10;                    &#10;                    // Force a fresh connection attempt&#10;                    connectToGuid(guid)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get connections that are in ERROR state&#10;     */&#10;    fun getErrorConnections(): List&lt;String&gt; {&#10;        return connections.filterValues { it.status == ConnectionStatus.ERROR }.keys.toList()&#10;    }&#10;&#10;    /**&#10;     * Force reconnect all active connections - disconnects and reconnects all current connections&#10;     */&#10;    fun forceReconnectAll() {&#10;        Log.i(TAG, &quot;Force reconnecting all active connections&quot;)&#10;&#10;        // Get all current connection GUIDs&#10;        val activeGuids = connections.keys.toList()&#10;&#10;        // Disconnect all connections first&#10;        activeGuids.forEach { guid -&gt;&#10;            connections[guid]?.let { connection -&gt;&#10;                // Cancel any pending reconnection attempts&#10;                connection.reconnectJob?.cancel()&#10;                // Close the WebSocket connection&#10;                connection.webSocket?.close(1000, &quot;Force reconnect&quot;)&#10;                Log.i(TAG, &quot;WebSocket connection closed for GUID: $guid&quot;)&#10;            }&#10;&#10;            // Remove from connections map&#10;            connections.remove(guid)&#10;            // Remove from connecting set if it was in there&#10;            connectingGuids.remove(guid)&#10;&#10;            // Update status to disconnected&#10;            val currentStatuses = _connectionStatuses.value.toMutableMap()&#10;            currentStatuses.remove(guid)&#10;            _connectionStatuses.value = currentStatuses&#10;&#10;            Log.i(TAG, &quot;WebSocket connection and status tracking removed for GUID: $guid&quot;)&#10;        }&#10;&#10;        // Give a moment for disconnections to complete, then reconnect&#10;        scope.launch {&#10;            kotlinx.coroutines.delay(500) // Wait 500ms for clean disconnection&#10;&#10;            Log.i(TAG, &quot;Starting forced reconnection for ${activeGuids.size} listeners&quot;)&#10;&#10;            // Reconnect to all previously active GUIDs&#10;            activeGuids.forEach { guid -&gt;&#10;                connectToGuid(guid)&#10;            }&#10;&#10;            Log.i(TAG, &quot;Force reconnect completed for all active listeners&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load server URL from SharedPreferences&#10;     */&#10;    private fun loadServerUrlFromPreferences(context: Context) {&#10;        try {&#10;            val sharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;            val savedUrl = sharedPreferences.getString(KEY_SERVER_URL, DEFAULT_SERVER_URL) ?: DEFAULT_SERVER_URL&#10;&#10;            // Update the base URL if it's different from default&#10;            if (savedUrl != DEFAULT_SERVER_URL) {&#10;                BASE_WS_URL = if (savedUrl.endsWith(&quot;/ws&quot;)) {&#10;                    savedUrl&#10;                } else {&#10;                    &quot;$savedUrl/ws&quot;&#10;                }&#10;                Log.i(TAG, &quot;Loaded server URL from preferences: $BASE_WS_URL&quot;)&#10;            } else {&#10;                Log.d(TAG, &quot;Using default server URL: $BASE_WS_URL&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error loading server URL from preferences, using default&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/receiver/BootReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/receiver/BootReceiver.kt" />
              <option name="updatedContent" value="package org.opennotification.opennotification_client.receiver&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import org.opennotification.opennotification_client.service.WatchdogService&#10;import org.opennotification.opennotification_client.utils.ConnectionKeepAlive&#10;&#10;/**&#10; * Boot receiver that ensures services restart after device reboot or app updates&#10; */&#10;class BootReceiver : BroadcastReceiver() {&#10;    companion object {&#10;        private const val TAG = &quot;BootReceiver&quot;&#10;    }&#10;&#10;    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;&#10;    override fun onReceive(context: Context, intent: Intent) {&#10;        val action = intent.action&#10;        Log.i(TAG, &quot;Boot receiver triggered with action: $action&quot;)&#10;&#10;        when (action) {&#10;            Intent.ACTION_BOOT_COMPLETED,&#10;            Intent.ACTION_LOCKED_BOOT_COMPLETED,&#10;            &quot;android.intent.action.QUICKBOOT_POWERON&quot; -&gt; {&#10;                Log.i(TAG, &quot;Device boot completed - starting services&quot;)&#10;                startServicesAfterBoot(context)&#10;            }&#10;            Intent.ACTION_MY_PACKAGE_REPLACED,&#10;            Intent.ACTION_PACKAGE_REPLACED -&gt; {&#10;                val packageName = intent.dataString&#10;                if (packageName?.contains(context.packageName) == true) {&#10;                    Log.i(TAG, &quot;App updated - restarting services&quot;)&#10;                    startServicesAfterBoot(context)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startServicesAfterBoot(context: Context) {&#10;        scope.launch {&#10;            try {&#10;                // Wait a bit for system to stabilize after boot&#10;                delay(5000)&#10;&#10;                Log.i(TAG, &quot;Starting watchdog service after boot&quot;)&#10;                WatchdogService.startService(context)&#10;&#10;                // Start keep-alive system&#10;                ConnectionKeepAlive.startKeepAlive(context)&#10;&#10;                Log.i(TAG, &quot;All services started successfully after boot&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error starting services after boot&quot;, e)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/service/WatchdogService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/service/WatchdogService.kt" />
              <option name="originalContent" value="package org.opennotification.opennotification_client.service&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.os.PowerManager&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.cancel&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import org.opennotification.opennotification_client.MainActivity&#10;import org.opennotification.opennotification_client.R&#10;&#10;class WatchdogService : Service() {&#10;    companion object {&#10;        private const val TAG = &quot;WatchdogService&quot;&#10;        private const val NOTIFICATION_ID = 2001&#10;        private const val CHANNEL_ID = &quot;websocket_service_channel&quot;&#10;        private const val CHANNEL_NAME = &quot;WebSocket Service&quot;&#10;        private const val WATCHDOG_INTERVAL = 2000L // 2 seconds (reduced from 5 seconds)&#10;        private const val ACTION_SHUTDOWN = &quot;org.opennotification.opennotification_client.ACTION_SHUTDOWN&quot;&#10;&#10;        fun startService(context: Context) {&#10;            val intent = Intent(context, WatchdogService::class.java)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                context.startForegroundService(intent)&#10;            } else {&#10;                context.startService(intent)&#10;            }&#10;        }&#10;&#10;        fun stopService(context: Context) {&#10;            val intent = Intent(context, WatchdogService::class.java)&#10;            context.stopService(intent)&#10;        }&#10;    }&#10;&#10;    private lateinit var notificationManager: NotificationManager&#10;    private lateinit var powerManager: PowerManager&#10;    private lateinit var wakeLock: PowerManager.WakeLock&#10;    private lateinit var webSocketManager: org.opennotification.opennotification_client.network.WebSocketManager&#10;    private val serviceScope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;    private var watchdogJob: Job? = null&#10;&#10;    // Flag to track if shutdown was requested&#10;    private var isShuttingDown = false&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.d(TAG, &quot;WatchdogService created&quot;)&#10;&#10;        notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager&#10;&#10;        // Initialize WebSocketManager with context to load saved server URL&#10;        org.opennotification.opennotification_client.network.WebSocketManager.initializeWithContext(this)&#10;        webSocketManager = org.opennotification.opennotification_client.network.WebSocketManager.getInstance()&#10;&#10;        // Acquire wake lock to prevent system from sleeping this service&#10;        wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;OpenNotification::WatchdogWakeLock&quot;&#10;        )&#10;        wakeLock.acquire(60 * 60 * 1000L) // 1 hour&#10;&#10;        createNotificationChannel()&#10;        startForeground(NOTIFICATION_ID, createConsolidatedNotification())&#10;&#10;        Log.i(TAG, &quot;Starting watchdog monitoring&quot;)&#10;        startWatchdog()&#10;&#10;        // Start battery-efficient keep-alive system&#10;        org.opennotification.opennotification_client.utils.ConnectionKeepAlive.startKeepAlive(this)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        Log.d(TAG, &quot;WatchdogService started&quot;)&#10;&#10;        // Handle shutdown action&#10;        if (intent?.action == ACTION_SHUTDOWN) {&#10;            Log.i(TAG, &quot;Shutdown action received - stopping all services&quot;)&#10;            handleShutdown()&#10;            return START_NOT_STICKY&#10;        }&#10;&#10;        // Don't restart watchdog if shutdown was requested&#10;        if (isShuttingDown) {&#10;            Log.i(TAG, &quot;Shutdown in progress - not restarting watchdog&quot;)&#10;            return START_NOT_STICKY&#10;        }&#10;&#10;        // Restart watchdog if it's not running&#10;        if (watchdogJob?.isActive != true) {&#10;            startWatchdog()&#10;        }&#10;&#10;        // Return START_STICKY to ensure the service restarts if killed&#10;        return START_STICKY&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;&#10;        // Only log error and restart if shutdown wasn't requested&#10;        if (!isShuttingDown) {&#10;            Log.d(TAG, &quot;WatchdogService destroyed unexpectedly - scheduling restart&quot;)&#10;            scheduleWatchdogRestart()&#10;        } else {&#10;            Log.i(TAG, &quot;WatchdogService destroyed as part of shutdown&quot;)&#10;        }&#10;&#10;        watchdogJob?.cancel()&#10;        serviceScope.cancel()&#10;&#10;        if (::wakeLock.isInitialized &amp;&amp; wakeLock.isHeld) {&#10;            wakeLock.release()&#10;        }&#10;    }&#10;&#10;    override fun onTaskRemoved(rootIntent: Intent?) {&#10;        Log.i(TAG, &quot;App task removed - checking if services should continue&quot;)&#10;&#10;        try {&#10;            // Check if we have active listeners before deciding to stay alive&#10;            val database = org.opennotification.opennotification_client.data.database.AppDatabase.getDatabase(applicationContext)&#10;            val repository = org.opennotification.opennotification_client.repository.NotificationRepository(database)&#10;&#10;            // Use runBlocking to get a synchronous result instead of launching a coroutine&#10;            val hasActiveListeners = try {&#10;                kotlinx.coroutines.runBlocking {&#10;                    // Use first() instead of collect to get just the first emission&#10;                    repository.getActiveListeners().first().isNotEmpty()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error checking active listeners on task removal&quot;, e)&#10;                false // Assume no active listeners if we can't check&#10;            }&#10;&#10;            if (hasActiveListeners &amp;&amp; !isShuttingDown) {&#10;                val activeListenerCount = kotlinx.coroutines.runBlocking {&#10;                    repository.getActiveListeners().first().size&#10;                }&#10;                Log.i(TAG, &quot;App swiped away but $activeListenerCount listeners are active - staying alive&quot;)&#10;                // Use normal notification text instead of custom &quot;monitoring&quot; text&#10;                updateConsolidatedNotification()&#10;&#10;                // Ensure we continue monitoring&#10;                if (watchdogJob?.isActive != true) {&#10;                    startWatchdog()&#10;                }&#10;            } else {&#10;                Log.i(TAG, &quot;App swiped away and no active listeners - shutting down&quot;)&#10;                // Set shutdown flag and stop all services&#10;                isShuttingDown = true&#10;                handleShutdown()&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error in onTaskRemoved&quot;, e)&#10;            // If we can't check, shutdown to be safe&#10;            isShuttingDown = true&#10;            handleShutdown()&#10;        }&#10;&#10;        // DON'T call super to prevent default behavior&#10;    }&#10;&#10;    private fun handleShutdown() {&#10;        try {&#10;            // Set shutdown flag to prevent restarts&#10;            isShuttingDown = true&#10;&#10;            // Stop battery-efficient keep-alive system&#10;            org.opennotification.opennotification_client.utils.ConnectionKeepAlive.stopKeepAlive(applicationContext)&#10;&#10;            // Stop WebSocket service&#10;            WebSocketService.stopService(applicationContext)&#10;&#10;            // Disconnect all WebSocket connections&#10;            webSocketManager.disconnectAll()&#10;&#10;            // Stop watchdog&#10;            watchdogJob?.cancel()&#10;&#10;            // Stop this service&#10;            stopSelf()&#10;&#10;            Log.i(TAG, &quot;All services shut down successfully&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during shutdown&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                CHANNEL_NAME,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Consolidated WebSocket and Watchdog service status&quot;&#10;                setShowBadge(false)&#10;                enableLights(false)&#10;                enableVibration(false)&#10;                lockscreenVisibility = Notification.VISIBILITY_PUBLIC&#10;            }&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    private fun createConsolidatedNotification(): Notification {&#10;        val intent = Intent(this, MainActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;        }&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            intent,&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            } else {&#10;                PendingIntent.FLAG_UPDATE_CURRENT&#10;            }&#10;        )&#10;&#10;        // Create shutdown action&#10;        val shutdownIntent = Intent(this, WatchdogService::class.java).apply {&#10;            action = ACTION_SHUTDOWN&#10;        }&#10;        val shutdownPendingIntent = PendingIntent.getService(&#10;            this,&#10;            1,&#10;            shutdownIntent,&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            } else {&#10;                PendingIntent.FLAG_UPDATE_CURRENT&#10;            }&#10;        )&#10;&#10;        // Get current status&#10;        val activeConnections = webSocketManager.getAllConnectionStatuses()&#10;            .count { it.value == org.opennotification.opennotification_client.data.models.ConnectionStatus.CONNECTED }&#10;&#10;        val contentText = if (activeConnections &gt; 0) {&#10;            &quot;WebSocket service active - $activeConnections connections&quot;&#10;        } else {&#10;            &quot;WebSocket service monitoring (no active connections)&quot;&#10;        }&#10;&#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;OpenNotification Service&quot;)&#10;            .setContentText(contentText)&#10;            .setSmallIcon(R.drawable.ic_notification)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setAutoCancel(false)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setCategory(NotificationCompat.CATEGORY_SERVICE)&#10;            .setForegroundServiceBehavior(NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE)&#10;            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#10;            .addAction(&#10;                R.drawable.ic_notification,&#10;                &quot;Shutdown&quot;,&#10;                shutdownPendingIntent&#10;            )&#10;            .build()&#10;    }&#10;&#10;    private fun updateConsolidatedNotification(customText: String? = null) {&#10;        try {&#10;            val activeConnections = webSocketManager.getAllConnectionStatuses()&#10;                .count { it.value == org.opennotification.opennotification_client.data.models.ConnectionStatus.CONNECTED }&#10;&#10;            val contentText = customText ?: if (activeConnections &gt; 0) {&#10;                &quot;WebSocket service active - $activeConnections connections&quot;&#10;            } else {&#10;                &quot;WebSocket service monitoring (no active connections)&quot;&#10;            }&#10;&#10;            val intent = Intent(this, MainActivity::class.java).apply {&#10;                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;            }&#10;&#10;            val pendingIntent = PendingIntent.getActivity(&#10;                this,&#10;                0,&#10;                intent,&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                } else {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT&#10;                }&#10;            )&#10;&#10;            // Create shutdown action&#10;            val shutdownIntent = Intent(this, WatchdogService::class.java).apply {&#10;                action = ACTION_SHUTDOWN&#10;            }&#10;            val shutdownPendingIntent = PendingIntent.getService(&#10;                this,&#10;                1,&#10;                shutdownIntent,&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                } else {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT&#10;                }&#10;            )&#10;&#10;            val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;                .setContentTitle(&quot;OpenNotification Service&quot;)&#10;                .setContentText(contentText)&#10;                .setSmallIcon(R.drawable.ic_notification)&#10;                .setContentIntent(pendingIntent)&#10;                .setOngoing(true)&#10;                .setAutoCancel(false)&#10;                .setPriority(NotificationCompat.PRIORITY_LOW)&#10;                .setCategory(NotificationCompat.CATEGORY_SERVICE)&#10;                .setForegroundServiceBehavior(NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE)&#10;                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#10;                .addAction(&#10;                    R.drawable.ic_notification,&#10;                    &quot;Shutdown&quot;,&#10;                    shutdownPendingIntent&#10;                )&#10;                .build()&#10;&#10;            notificationManager.notify(NOTIFICATION_ID, notification)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to update consolidated notification&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun startWatchdog() {&#10;        Log.i(TAG, &quot;Starting watchdog monitoring&quot;)&#10;&#10;        watchdogJob = serviceScope.launch {&#10;            while (isActive) {&#10;                try {&#10;                    // Check if WebSocketService is running&#10;                    val isWebSocketServiceRunning = isServiceRunning(WebSocketService::class.java.name)&#10;&#10;                    if (!isWebSocketServiceRunning) {&#10;                        // Check if we should restart the WebSocket service&#10;                        if (shouldRestartWebSocketService()) {&#10;                            Log.w(TAG, &quot;WebSocketService is not running but should - restarting it&quot;)&#10;                            WebSocketService.startService(applicationContext)&#10;                        } else {&#10;                            Log.d(TAG, &quot;WebSocketService is not running and should not be running&quot;)&#10;                        }&#10;                    } else {&#10;                        Log.d(TAG, &quot;WebSocketService is running normally&quot;)&#10;                    }&#10;&#10;                    // Update the consolidated notification with current status&#10;                    updateConsolidatedNotification()&#10;&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error in watchdog monitoring&quot;, e)&#10;                }&#10;&#10;                delay(WATCHDOG_INTERVAL)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isServiceRunning(serviceName: String): Boolean {&#10;        return try {&#10;            val activityManager = getSystemService(Context.ACTIVITY_SERVICE) as android.app.ActivityManager&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val services = activityManager.getRunningServices(Integer.MAX_VALUE)&#10;            services.any { it.service.className == serviceName }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error checking if service is running&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private suspend fun shouldRestartWebSocketService(): Boolean {&#10;        return try {&#10;            // Check if there are active listeners that need WebSocket connections&#10;            val database = org.opennotification.opennotification_client.data.database.AppDatabase.getDatabase(applicationContext)&#10;            val repository = org.opennotification.opennotification_client.repository.NotificationRepository(database)&#10;&#10;            // Use first() to get just the first emission instead of collect&#10;            repository.getActiveListeners().first().isNotEmpty()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error checking for active listeners&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun scheduleWatchdogRestart() {&#10;        try {&#10;            val restartIntent = Intent(applicationContext, WatchdogService::class.java)&#10;            val pendingIntent = PendingIntent.getService(&#10;                applicationContext,&#10;                3001,&#10;                restartIntent,&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                } else {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT&#10;                }&#10;            )&#10;&#10;            val alarmManager = getSystemService(Context.ALARM_SERVICE) as android.app.AlarmManager&#10;            val triggerTime = System.currentTimeMillis() + 2000 // 2 seconds&#10;&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    android.app.AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                )&#10;            } else {&#10;                alarmManager.setExact(&#10;                    android.app.AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                )&#10;            }&#10;            Log.i(TAG, &quot;Scheduled watchdog restart&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to schedule watchdog restart&quot;, e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.opennotification.opennotification_client.service&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.os.PowerManager&#10;import android.os.Process&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.cancel&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import org.opennotification.opennotification_client.MainActivity&#10;import org.opennotification.opennotification_client.R&#10;import org.opennotification.opennotification_client.utils.MemoryPressureHandler&#10;&#10;class WatchdogService : Service() {&#10;    companion object {&#10;        private const val TAG = &quot;WatchdogService&quot;&#10;        private const val NOTIFICATION_ID = 2001&#10;        private const val CHANNEL_ID = &quot;websocket_service_channel&quot;&#10;        private const val CHANNEL_NAME = &quot;WebSocket Service&quot;&#10;        private const val WATCHDOG_INTERVAL = 2000L // 2 seconds (reduced from 5 seconds)&#10;        private const val ACTION_SHUTDOWN = &quot;org.opennotification.opennotification_client.ACTION_SHUTDOWN&quot;&#10;&#10;        fun startService(context: Context) {&#10;            val intent = Intent(context, WatchdogService::class.java)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                context.startForegroundService(intent)&#10;            } else {&#10;                context.startService(intent)&#10;            }&#10;        }&#10;&#10;        fun stopService(context: Context) {&#10;            val intent = Intent(context, WatchdogService::class.java)&#10;            context.stopService(intent)&#10;        }&#10;    }&#10;&#10;    private lateinit var notificationManager: NotificationManager&#10;    private lateinit var powerManager: PowerManager&#10;    private lateinit var wakeLock: PowerManager.WakeLock&#10;    private lateinit var webSocketManager: org.opennotification.opennotification_client.network.WebSocketManager&#10;    private lateinit var memoryPressureHandler: MemoryPressureHandler&#10;    private val serviceScope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;    private var watchdogJob: Job? = null&#10;&#10;    // Flag to track if shutdown was requested&#10;    private var isShuttingDown = false&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.d(TAG, &quot;WatchdogService created&quot;)&#10;&#10;        // Set maximum process priority to prevent being killed&#10;        try {&#10;            Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO)&#10;            // Note: setOomScoreAdj is not available in Android SDK - using other priority mechanisms&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Could not set maximum priority - continuing with normal priority&quot;, e)&#10;        }&#10;&#10;        notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager&#10;&#10;        // Initialize memory pressure protection&#10;        memoryPressureHandler = MemoryPressureHandler(this)&#10;        memoryPressureHandler.startProtection()&#10;&#10;        // Initialize WebSocketManager with context to load saved server URL&#10;        org.opennotification.opennotification_client.network.WebSocketManager.initializeWithContext(this)&#10;        webSocketManager = org.opennotification.opennotification_client.network.WebSocketManager.getInstance()&#10;&#10;        // Acquire wake lock to prevent system from sleeping this service&#10;        wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;OpenNotification::WatchdogWakeLock&quot;&#10;        )&#10;        wakeLock.acquire(60 * 60 * 1000L) // 1 hour&#10;&#10;        createNotificationChannel()&#10;        startForeground(NOTIFICATION_ID, createConsolidatedNotification())&#10;&#10;        Log.i(TAG, &quot;Starting watchdog monitoring&quot;)&#10;        startWatchdog()&#10;&#10;        // Start battery-efficient keep-alive system&#10;        org.opennotification.opennotification_client.utils.ConnectionKeepAlive.startKeepAlive(this)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        Log.d(TAG, &quot;WatchdogService started&quot;)&#10;&#10;        // Boost priority on each start command&#10;        try {&#10;            Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO)&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Could not boost priority on start command&quot;, e)&#10;        }&#10;&#10;        // Handle shutdown action&#10;        if (intent?.action == ACTION_SHUTDOWN) {&#10;            Log.i(TAG, &quot;Shutdown action received - stopping all services&quot;)&#10;            handleShutdown()&#10;            return START_NOT_STICKY&#10;        }&#10;&#10;        // Don't restart watchdog if shutdown was requested&#10;        if (isShuttingDown) {&#10;            Log.i(TAG, &quot;Shutdown in progress - not restarting watchdog&quot;)&#10;            return START_NOT_STICKY&#10;        }&#10;&#10;        // Restart watchdog if it's not running&#10;        if (watchdogJob?.isActive != true) {&#10;            startWatchdog()&#10;        }&#10;&#10;        // Return START_STICKY to ensure the service restarts if killed&#10;        return START_STICKY&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;&#10;        // Stop memory pressure protection&#10;        memoryPressureHandler.stopProtection()&#10;&#10;        // Only log error and restart if shutdown wasn't requested&#10;        if (!isShuttingDown) {&#10;            Log.d(TAG, &quot;WatchdogService destroyed unexpectedly - scheduling restart&quot;)&#10;            scheduleWatchdogRestart()&#10;        } else {&#10;            Log.i(TAG, &quot;WatchdogService destroyed as part of shutdown&quot;)&#10;        }&#10;&#10;        watchdogJob?.cancel()&#10;        serviceScope.cancel()&#10;&#10;        if (::wakeLock.isInitialized &amp;&amp; wakeLock.isHeld) {&#10;            wakeLock.release()&#10;        }&#10;    }&#10;&#10;    override fun onTaskRemoved(rootIntent: Intent?) {&#10;        Log.i(TAG, &quot;App task removed - checking if services should continue&quot;)&#10;&#10;        try {&#10;            // Check if we have active listeners before deciding to stay alive&#10;            val database = org.opennotification.opennotification_client.data.database.AppDatabase.getDatabase(applicationContext)&#10;            val repository = org.opennotification.opennotification_client.repository.NotificationRepository(database)&#10;&#10;            // Use runBlocking to get a synchronous result instead of launching a coroutine&#10;            val hasActiveListeners = try {&#10;                kotlinx.coroutines.runBlocking {&#10;                    // Use first() instead of collect to get just the first emission&#10;                    repository.getActiveListeners().first().isNotEmpty()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error checking active listeners on task removal&quot;, e)&#10;                false // Assume no active listeners if we can't check&#10;            }&#10;&#10;            if (hasActiveListeners &amp;&amp; !isShuttingDown) {&#10;                val activeListenerCount = kotlinx.coroutines.runBlocking {&#10;                    repository.getActiveListeners().first().size&#10;                }&#10;                Log.i(TAG, &quot;App swiped away but $activeListenerCount listeners are active - staying alive&quot;)&#10;&#10;                // Boost priority to survive memory pressure&#10;                try {&#10;                    Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO)&#10;                } catch (e: Exception) {&#10;                    Log.w(TAG, &quot;Could not boost priority after task removal&quot;, e)&#10;                }&#10;&#10;                // Use normal notification text instead of custom &quot;monitoring&quot; text&#10;                updateConsolidatedNotification()&#10;&#10;                // Ensure we continue monitoring&#10;                if (watchdogJob?.isActive != true) {&#10;                    startWatchdog()&#10;                }&#10;            } else {&#10;                Log.i(TAG, &quot;App swiped away and no active listeners - shutting down&quot;)&#10;                // Set shutdown flag and stop all services&#10;                isShuttingDown = true&#10;                handleShutdown()&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error in onTaskRemoved&quot;, e)&#10;            // If we can't check, shutdown to be safe&#10;            isShuttingDown = true&#10;            handleShutdown()&#10;        }&#10;&#10;        // DON'T call super to prevent default behavior&#10;    }&#10;&#10;    override fun onTrimMemory(level: Int) {&#10;        Log.w(TAG, &quot;WatchdogService received memory trim request: $level&quot;)&#10;&#10;        // Don't call super - we want to resist being trimmed&#10;        when (level) {&#10;            TRIM_MEMORY_RUNNING_CRITICAL,&#10;            TRIM_MEMORY_COMPLETE -&gt; {&#10;                Log.w(TAG, &quot;Critical memory pressure on WatchdogService - taking defensive action&quot;)&#10;&#10;                // Boost our priority to maximum&#10;                try {&#10;                    Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO)&#10;                    // Note: setOomScoreAdj is not available in Android SDK - using thread priority instead&#10;                } catch (e: Exception) {&#10;                    Log.w(TAG, &quot;Could not boost priority during memory pressure&quot;, e)&#10;                }&#10;&#10;                // Force GC to free up any memory we can&#10;                System.gc()&#10;&#10;                // Schedule immediate restart in case we get killed&#10;                scheduleWatchdogRestart()&#10;            }&#10;            else -&gt; {&#10;                // For other memory trim levels, just boost priority&#10;                try {&#10;                    Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO)&#10;                } catch (e: Exception) {&#10;                    Log.w(TAG, &quot;Could not boost priority during moderate memory pressure&quot;, e)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleShutdown() {&#10;        try {&#10;            // Set shutdown flag to prevent restarts&#10;            isShuttingDown = true&#10;&#10;            // Stop battery-efficient keep-alive system&#10;            org.opennotification.opennotification_client.utils.ConnectionKeepAlive.stopKeepAlive(applicationContext)&#10;&#10;            // Stop WebSocket service&#10;            WebSocketService.stopService(applicationContext)&#10;&#10;            // Disconnect all WebSocket connections&#10;            webSocketManager.disconnectAll()&#10;&#10;            // Stop watchdog&#10;            watchdogJob?.cancel()&#10;&#10;            // Stop this service&#10;            stopSelf()&#10;&#10;            Log.i(TAG, &quot;All services shut down successfully&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during shutdown&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                CHANNEL_NAME,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Consolidated WebSocket and Watchdog service status&quot;&#10;                setShowBadge(false)&#10;                enableLights(false)&#10;                enableVibration(false)&#10;                lockscreenVisibility = Notification.VISIBILITY_PUBLIC&#10;            }&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    private fun createConsolidatedNotification(): Notification {&#10;        val intent = Intent(this, MainActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;        }&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            intent,&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            } else {&#10;                PendingIntent.FLAG_UPDATE_CURRENT&#10;            }&#10;        )&#10;&#10;        // Create shutdown action&#10;        val shutdownIntent = Intent(this, WatchdogService::class.java).apply {&#10;            action = ACTION_SHUTDOWN&#10;        }&#10;        val shutdownPendingIntent = PendingIntent.getService(&#10;            this,&#10;            1,&#10;            shutdownIntent,&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            } else {&#10;                PendingIntent.FLAG_UPDATE_CURRENT&#10;            }&#10;        )&#10;&#10;        // Get current status&#10;        val activeConnections = webSocketManager.getAllConnectionStatuses()&#10;            .count { it.value == org.opennotification.opennotification_client.data.models.ConnectionStatus.CONNECTED }&#10;&#10;        val contentText = if (activeConnections &gt; 0) {&#10;            &quot;WebSocket service active - $activeConnections connections&quot;&#10;        } else {&#10;            &quot;WebSocket service monitoring (no active connections)&quot;&#10;        }&#10;&#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;OpenNotification Service&quot;)&#10;            .setContentText(contentText)&#10;            .setSmallIcon(R.drawable.ic_notification)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setAutoCancel(false)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setCategory(NotificationCompat.CATEGORY_SERVICE)&#10;            .setForegroundServiceBehavior(NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE)&#10;            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#10;            .addAction(&#10;                R.drawable.ic_notification,&#10;                &quot;Shutdown&quot;,&#10;                shutdownPendingIntent&#10;            )&#10;            .build()&#10;    }&#10;&#10;    private fun updateConsolidatedNotification(customText: String? = null) {&#10;        try {&#10;            val activeConnections = webSocketManager.getAllConnectionStatuses()&#10;                .count { it.value == org.opennotification.opennotification_client.data.models.ConnectionStatus.CONNECTED }&#10;&#10;            val contentText = customText ?: if (activeConnections &gt; 0) {&#10;                &quot;WebSocket service active - $activeConnections connections&quot;&#10;            } else {&#10;                &quot;WebSocket service monitoring (no active connections)&quot;&#10;            }&#10;&#10;            val intent = Intent(this, MainActivity::class.java).apply {&#10;                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;            }&#10;&#10;            val pendingIntent = PendingIntent.getActivity(&#10;                this,&#10;                0,&#10;                intent,&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                } else {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT&#10;                }&#10;            )&#10;&#10;            // Create shutdown action&#10;            val shutdownIntent = Intent(this, WatchdogService::class.java).apply {&#10;                action = ACTION_SHUTDOWN&#10;            }&#10;            val shutdownPendingIntent = PendingIntent.getService(&#10;                this,&#10;                1,&#10;                shutdownIntent,&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                } else {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT&#10;                }&#10;            )&#10;&#10;            val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;                .setContentTitle(&quot;OpenNotification Service&quot;)&#10;                .setContentText(contentText)&#10;                .setSmallIcon(R.drawable.ic_notification)&#10;                .setContentIntent(pendingIntent)&#10;                .setOngoing(true)&#10;                .setAutoCancel(false)&#10;                .setPriority(NotificationCompat.PRIORITY_LOW)&#10;                .setCategory(NotificationCompat.CATEGORY_SERVICE)&#10;                .setForegroundServiceBehavior(NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE)&#10;                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#10;                .addAction(&#10;                    R.drawable.ic_notification,&#10;                    &quot;Shutdown&quot;,&#10;                    shutdownPendingIntent&#10;                )&#10;                .build()&#10;&#10;            notificationManager.notify(NOTIFICATION_ID, notification)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to update consolidated notification&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun startWatchdog() {&#10;        Log.i(TAG, &quot;Starting watchdog monitoring&quot;)&#10;&#10;        watchdogJob = serviceScope.launch {&#10;            while (isActive) {&#10;                try {&#10;                    // Check if WebSocketService is running&#10;                    val isWebSocketServiceRunning = isServiceRunning(WebSocketService::class.java.name)&#10;&#10;                    if (!isWebSocketServiceRunning) {&#10;                        // Check if we should restart the WebSocket service&#10;                        if (shouldRestartWebSocketService()) {&#10;                            Log.w(TAG, &quot;WebSocketService is not running but should - restarting it&quot;)&#10;                            WebSocketService.startService(applicationContext)&#10;                        } else {&#10;                            Log.d(TAG, &quot;WebSocketService is not running and should not be running&quot;)&#10;                        }&#10;                    } else {&#10;                        Log.d(TAG, &quot;WebSocketService is running normally&quot;)&#10;                    }&#10;&#10;                    // Update the consolidated notification with current status&#10;                    updateConsolidatedNotification()&#10;&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error in watchdog monitoring&quot;, e)&#10;                }&#10;&#10;                delay(WATCHDOG_INTERVAL)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isServiceRunning(serviceName: String): Boolean {&#10;        return try {&#10;            val activityManager = getSystemService(Context.ACTIVITY_SERVICE) as android.app.ActivityManager&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val services = activityManager.getRunningServices(Integer.MAX_VALUE)&#10;            services.any { it.service.className == serviceName }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error checking if service is running&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private suspend fun shouldRestartWebSocketService(): Boolean {&#10;        return try {&#10;            // Check if there are active listeners that need WebSocket connections&#10;            val database = org.opennotification.opennotification_client.data.database.AppDatabase.getDatabase(applicationContext)&#10;            val repository = org.opennotification.opennotification_client.repository.NotificationRepository(database)&#10;&#10;            // Use first() to get just the first emission instead of collect&#10;            repository.getActiveListeners().first().isNotEmpty()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error checking for active listeners&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun scheduleWatchdogRestart() {&#10;        try {&#10;            val restartIntent = Intent(applicationContext, WatchdogService::class.java)&#10;            val pendingIntent = PendingIntent.getService(&#10;                applicationContext,&#10;                3001,&#10;                restartIntent,&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                } else {&#10;                    PendingIntent.FLAG_UPDATE_CURRENT&#10;                }&#10;            )&#10;&#10;            val alarmManager = getSystemService(Context.ALARM_SERVICE) as android.app.AlarmManager&#10;            val triggerTime = System.currentTimeMillis() + 1000 // 1 second (reduced for faster recovery)&#10;&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    android.app.AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                )&#10;            } else {&#10;                alarmManager.setExact(&#10;                    android.app.AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                )&#10;            }&#10;            Log.i(TAG, &quot;Scheduled watchdog restart with high-priority alarm&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to schedule watchdog restart&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/utils/MemoryPressureHandler.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/utils/MemoryPressureHandler.kt" />
              <option name="updatedContent" value="package org.opennotification.opennotification_client.utils&#10;&#10;import android.app.ActivityManager&#10;import android.app.AlarmManager&#10;import android.app.PendingIntent&#10;import android.content.BroadcastReceiver&#10;import android.content.ComponentCallbacks2&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.os.Build&#10;import android.os.Process&#10;import android.util.Log&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import org.opennotification.opennotification_client.service.WatchdogService&#10;&#10;/**&#10; * Handles memory pressure and prevents app termination using multiple strategies&#10; */&#10;class MemoryPressureHandler(private val context: Context) : ComponentCallbacks2 {&#10;    companion object {&#10;        private const val TAG = &quot;MemoryPressureHandler&quot;&#10;        private const val ACTION_RESURRECTION = &quot;org.opennotification.opennotification_client.RESURRECTION&quot;&#10;        private const val RESURRECTION_DELAY = 10000L // 10 seconds&#10;        &#10;        // High priority OOM adjustment values&#10;        private const val FOREGROUND_APP_ADJ = 0&#10;        private const val VISIBLE_APP_ADJ = 100&#10;        private const val PERCEPTIBLE_APP_ADJ = 200&#10;    }&#10;&#10;    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;    private var isRegistered = false&#10;&#10;    /**&#10;     * Start comprehensive memory pressure protection&#10;     */&#10;    fun startProtection() {&#10;        if (!isRegistered) {&#10;            context.registerComponentCallbacks(this)&#10;            registerResurrectionReceiver()&#10;            schedulePeriodicResurrection()&#10;            setHighPriorityOomAdj()&#10;            isRegistered = true&#10;            Log.i(TAG, &quot;Memory pressure protection started&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Stop memory pressure protection&#10;     */&#10;    fun stopProtection() {&#10;        if (isRegistered) {&#10;            try {&#10;                context.unregisterComponentCallbacks(this)&#10;                unregisterResurrectionReceiver()&#10;                cancelPeriodicResurrection()&#10;                isRegistered = false&#10;                Log.i(TAG, &quot;Memory pressure protection stopped&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error stopping memory pressure protection&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onTrimMemory(level: Int) {&#10;        Log.w(TAG, &quot;Memory trim requested with level: $level&quot;)&#10;        &#10;        when (level) {&#10;            ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL,&#10;            ComponentCallbacks2.TRIM_MEMORY_COMPLETE -&gt; {&#10;                Log.w(TAG, &quot;Critical memory pressure detected - taking defensive actions&quot;)&#10;                handleCriticalMemoryPressure()&#10;            }&#10;            ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW,&#10;            ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE -&gt; {&#10;                Log.w(TAG, &quot;Moderate memory pressure detected - optimizing&quot;)&#10;                handleModerateMemoryPressure()&#10;            }&#10;            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND,&#10;            ComponentCallbacks2.TRIM_MEMORY_MODERATE -&gt; {&#10;                Log.w(TAG, &quot;Background memory pressure - preparing for potential termination&quot;)&#10;                prepareForTermination()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onConfigurationChanged(newConfig: android.content.res.Configuration) {&#10;        // Required implementation - no action needed&#10;    }&#10;&#10;    override fun onLowMemory() {&#10;        Log.w(TAG, &quot;System low memory warning received&quot;)&#10;        handleCriticalMemoryPressure()&#10;    }&#10;&#10;    private fun handleCriticalMemoryPressure() {&#10;        scope.launch {&#10;            try {&#10;                Log.w(TAG, &quot;Handling critical memory pressure&quot;)&#10;                &#10;                // Schedule immediate resurrection in case we're killed&#10;                scheduleImmediateResurrection()&#10;                &#10;                // Force garbage collection&#10;                System.gc()&#10;                &#10;                // Reduce memory footprint by disconnecting idle connections&#10;                val webSocketManager = org.opennotification.opennotification_client.network.WebSocketManager.getInstance()&#10;                val errorConnections = webSocketManager.getErrorConnections()&#10;                if (errorConnections.isNotEmpty()) {&#10;                    Log.i(TAG, &quot;Disconnecting ${errorConnections.size} error connections to free memory&quot;)&#10;                    errorConnections.forEach { guid -&gt;&#10;                        webSocketManager.disconnectFromGuid(guid)&#10;                    }&#10;                }&#10;                &#10;                // Increase service priority&#10;                setHighPriorityOomAdj()&#10;                &#10;                Log.i(TAG, &quot;Critical memory pressure handling completed&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error handling critical memory pressure&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleModerateMemoryPressure() {&#10;        scope.launch {&#10;            try {&#10;                Log.w(TAG, &quot;Handling moderate memory pressure&quot;)&#10;                &#10;                // Force garbage collection&#10;                System.gc()&#10;                &#10;                // Schedule resurrection as precaution&#10;                scheduleImmediateResurrection()&#10;                &#10;                Log.i(TAG, &quot;Moderate memory pressure handling completed&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error handling moderate memory pressure&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun prepareForTermination() {&#10;        scope.launch {&#10;            try {&#10;                Log.w(TAG, &quot;Preparing for potential termination&quot;)&#10;                &#10;                // Schedule resurrection&#10;                scheduleImmediateResurrection()&#10;                &#10;                // Ensure watchdog service is running with highest priority&#10;                WatchdogService.startService(context)&#10;                &#10;                // Start keep-alive system if not running&#10;                ConnectionKeepAlive.startKeepAlive(context)&#10;                &#10;                Log.i(TAG, &quot;Termination preparation completed&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error preparing for termination&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setHighPriorityOomAdj() {&#10;        try {&#10;            // Try to set process priority to foreground&#10;            Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND)&#10;            &#10;            // Get activity manager and try to move to foreground importance&#10;            val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager&#10;            &#10;            // Log current memory info&#10;            val memoryInfo = ActivityManager.MemoryInfo()&#10;            activityManager.getMemoryInfo(memoryInfo)&#10;            &#10;            Log.i(TAG, &quot;Memory info - Available: ${memoryInfo.availMem / 1024 / 1024}MB, &quot; +&#10;                    &quot;Total: ${memoryInfo.totalMem / 1024 / 1024}MB, &quot; +&#10;                    &quot;Low memory: ${memoryInfo.lowMemory}&quot;)&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error setting high priority OOM adjustment&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun scheduleImmediateResurrection() {&#10;        scheduleResurrection(2000L) // 2 seconds&#10;    }&#10;&#10;    private fun schedulePeriodicResurrection() {&#10;        scheduleResurrection(RESURRECTION_DELAY)&#10;    }&#10;&#10;    private fun scheduleResurrection(delay: Long) {&#10;        try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, ResurrectionReceiver::class.java).apply {&#10;                action = ACTION_RESURRECTION&#10;            }&#10;            &#10;            val pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                2001,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;&#10;            val triggerTime = System.currentTimeMillis() + delay&#10;&#10;            // Use the most aggressive alarm type available&#10;            when {&#10;                Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M -&gt; {&#10;                    alarmManager.setExactAndAllowWhileIdle(&#10;                        AlarmManager.RTC_WAKEUP,&#10;                        triggerTime,&#10;                        pendingIntent&#10;                    )&#10;                }&#10;                else -&gt; {&#10;                    alarmManager.setExact(&#10;                        AlarmManager.RTC_WAKEUP,&#10;                        triggerTime,&#10;                        pendingIntent&#10;                    )&#10;                }&#10;            }&#10;&#10;            Log.i(TAG, &quot;Resurrection alarm scheduled for ${delay}ms from now&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error scheduling resurrection&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun cancelPeriodicResurrection() {&#10;        try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, ResurrectionReceiver::class.java).apply {&#10;                action = ACTION_RESURRECTION&#10;            }&#10;            &#10;            val pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                2001,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;&#10;            alarmManager.cancel(pendingIntent)&#10;            Log.i(TAG, &quot;Resurrection alarm cancelled&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error cancelling resurrection&quot;, e)&#10;        }&#10;    }&#10;&#10;    private lateinit var resurrectionReceiver: ResurrectionReceiver&#10;&#10;    private fun registerResurrectionReceiver() {&#10;        resurrectionReceiver = ResurrectionReceiver()&#10;        val filter = IntentFilter(ACTION_RESURRECTION)&#10;        context.registerReceiver(resurrectionReceiver, filter)&#10;        Log.i(TAG, &quot;Resurrection receiver registered&quot;)&#10;    }&#10;&#10;    private fun unregisterResurrectionReceiver() {&#10;        try {&#10;            context.unregisterReceiver(resurrectionReceiver)&#10;            Log.i(TAG, &quot;Resurrection receiver unregistered&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error unregistering resurrection receiver&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Receiver that resurrects the app if it gets killed&#10;     */&#10;    inner class ResurrectionReceiver : BroadcastReceiver() {&#10;        override fun onReceive(context: Context, intent: Intent) {&#10;            if (intent.action == ACTION_RESURRECTION) {&#10;                Log.w(TAG, &quot;Resurrection alarm triggered - checking if services need restart&quot;)&#10;                &#10;                scope.launch {&#10;                    try {&#10;                        // Check if watchdog service is running&#10;                        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager&#10;                        @Suppress(&quot;DEPRECATION&quot;)&#10;                        val services = activityManager.getRunningServices(Integer.MAX_VALUE)&#10;                        val watchdogRunning = services.any { &#10;                            it.service.className == &quot;org.opennotification.opennotification_client.service.WatchdogService&quot; &#10;                        }&#10;&#10;                        if (!watchdogRunning) {&#10;                            Log.w(TAG, &quot;Watchdog service not running - restarting it&quot;)&#10;                            WatchdogService.startService(context)&#10;                            &#10;                            // Also restart keep-alive&#10;                            ConnectionKeepAlive.startKeepAlive(context)&#10;                        } else {&#10;                            Log.d(TAG, &quot;Watchdog service is running normally&quot;)&#10;                        }&#10;&#10;                        // Schedule next resurrection check&#10;                        schedulePeriodicResurrection()&#10;                        &#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Error in resurrection receiver&quot;, e)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>