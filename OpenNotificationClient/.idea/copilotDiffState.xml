<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/ui/screens/MainScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/ui/screens/MainScreen.kt" />
              <option name="originalContent" value="package org.opennotification.opennotification_client.ui.screens&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Notifications&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.pulltorefresh.PullToRefreshBox&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import org.opennotification.opennotification_client.ui.components.AddListenerDialog&#10;import org.opennotification.opennotification_client.ui.components.ListenerItem&#10;import org.opennotification.opennotification_client.viewmodel.MainViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainScreen(&#10;    onNavigateToSettings: () -&gt; Unit = {},&#10;    onNavigateToNotificationHistory: () -&gt; Unit = {},&#10;    viewModel: MainViewModel = viewModel()&#10;) {&#10;    val listeners by viewModel.allListeners.collectAsState(initial = emptyList())&#10;    val connectionStatuses by viewModel.connectionStatuses.collectAsState(initial = emptyMap())&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val errorMessage by viewModel.errorMessage.collectAsState()&#10;    &#10;    // Collecte des états de reconnexion séquentielle&#10;    val sequentialCurrentGuid by viewModel.sequentialCurrentGuid.collectAsState(initial = null)&#10;    val sequentialWaitingGuids by viewModel.sequentialWaitingGuids.collectAsState(initial = emptySet())&#10;&#10;    var showAddDialog by remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Connections&quot;) },&#10;                actions = {&#10;                    IconButton(onClick = onNavigateToNotificationHistory) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Notifications,&#10;                            contentDescription = &quot;Notification History&quot;,&#10;                            tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                        )&#10;                    }&#10;                    IconButton(onClick = onNavigateToSettings) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Settings,&#10;                            contentDescription = &quot;Settings&quot;,&#10;                            tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            FloatingActionButton(&#10;                onClick = { showAddDialog = true },&#10;                containerColor = MaterialTheme.colorScheme.primary,&#10;                shape = androidx.compose.foundation.shape.CircleShape&#10;            ) {&#10;                Icon(Icons.Default.Add, contentDescription = &quot;Add Listener&quot;)&#10;            }&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;        ) {&#10;            errorMessage?.let { message -&gt;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.errorContainer&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(16.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = message,&#10;                            color = MaterialTheme.colorScheme.onErrorContainer,&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                        TextButton(&#10;                            onClick = { viewModel.clearError() }&#10;                        ) {&#10;                            Text(&quot;Dismiss&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            PullToRefreshBox(&#10;                isRefreshing = isLoading,&#10;                onRefresh = { viewModel.refreshConnections() },&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                if (listeners.isEmpty() &amp;&amp; !isLoading) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Column(&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;No listeners added yet&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            Text(&#10;                                text = &quot;Tap the + button to add a WebSocket listener&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&#10;                                text = &quot;Pull down to refresh connections&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentPadding = PaddingValues(16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        items(&#10;                            items = listeners,&#10;                            key = { it.id }&#10;                        ) { listener -&gt;&#10;                            ListenerItem(&#10;                                listener = listener,&#10;                                connectionStatus = connectionStatuses[listener.guid],&#10;                                onToggleStatus = { viewModel.toggleListenerStatus(listener) },&#10;                                onDelete = { viewModel.deleteListener(listener) },&#10;                                onRename = { newName -&gt; viewModel.renameListener(listener, newName) },&#10;                                sequentialCurrentGuid = sequentialCurrentGuid,&#10;                                sequentialWaitingGuids = sequentialWaitingGuids&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        if (showAddDialog) {&#10;            AddListenerDialog(&#10;                onDismiss = { showAddDialog = false },&#10;                onConfirm = { guid: String, name: String? -&gt;&#10;                    viewModel.addNewListener(guid, name)&#10;                    showAddDialog = false&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.opennotification.opennotification_client.ui.screens&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Notifications&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.pulltorefresh.PullToRefreshBox&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import org.opennotification.opennotification_client.ui.components.AddListenerDialog&#10;import org.opennotification.opennotification_client.ui.components.ListenerItem&#10;import org.opennotification.opennotification_client.viewmodel.MainViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainScreen(&#10;    onNavigateToSettings: () -&gt; Unit = {},&#10;    onNavigateToNotificationHistory: () -&gt; Unit = {},&#10;    viewModel: MainViewModel = viewModel()&#10;) {&#10;    val listeners by viewModel.allListeners.collectAsState(initial = emptyList())&#10;    val connectionStatuses by viewModel.connectionStatuses.collectAsState(initial = emptyMap())&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val errorMessage by viewModel.errorMessage.collectAsState()&#10;    &#10;    // Collecte des états de reconnexion séquentielle&#10;    val sequentialCurrentGuid by viewModel.sequentialCurrentGuid.collectAsState(initial = null)&#10;    val sequentialWaitingGuids by viewModel.sequentialWaitingGuids.collectAsState(initial = emptySet())&#10;&#10;    var showAddDialog by remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Connections&quot;) },&#10;                actions = {&#10;                    IconButton(onClick = onNavigateToNotificationHistory) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Notifications,&#10;                            contentDescription = &quot;Notification History&quot;,&#10;                            tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                        )&#10;                    }&#10;                    IconButton(onClick = onNavigateToSettings) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Settings,&#10;                            contentDescription = &quot;Settings&quot;,&#10;                            tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            FloatingActionButton(&#10;                onClick = { showAddDialog = true },&#10;                containerColor = MaterialTheme.colorScheme.primary,&#10;                shape = androidx.compose.foundation.shape.CircleShape&#10;            ) {&#10;                Icon(Icons.Default.Add, contentDescription = &quot;Add Listener&quot;)&#10;            }&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;        ) {&#10;            errorMessage?.let { message -&gt;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.errorContainer&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(16.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = message,&#10;                            color = MaterialTheme.colorScheme.onErrorContainer,&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                        TextButton(&#10;                            onClick = { viewModel.clearError() }&#10;                        ) {&#10;                            Text(&quot;Dismiss&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            PullToRefreshBox(&#10;                isRefreshing = isLoading,&#10;                onRefresh = { viewModel.refreshConnections() },&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                if (listeners.isEmpty() &amp;&amp; !isLoading) {&#10;                    // Afficher le message uniquement si la liste est vide ET qu'on n'est pas en train de charger&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Column(&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;No listeners added yet&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            Text(&#10;                                text = &quot;Tap the + button to add a WebSocket listener&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&#10;                                text = &quot;Pull down to refresh connections&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    // Toujours afficher la LazyColumn, même si elle est vide pendant le chargement&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentPadding = PaddingValues(16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        items(&#10;                            items = listeners,&#10;                            key = { it.id }&#10;                        ) { listener -&gt;&#10;                            ListenerItem(&#10;                                listener = listener,&#10;                                connectionStatus = connectionStatuses[listener.guid],&#10;                                onToggleStatus = { viewModel.toggleListenerStatus(listener) },&#10;                                onDelete = { viewModel.deleteListener(listener) },&#10;                                onRename = { newName -&gt; viewModel.renameListener(listener, newName) },&#10;                                sequentialCurrentGuid = sequentialCurrentGuid,&#10;                                sequentialWaitingGuids = sequentialWaitingGuids&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        if (showAddDialog) {&#10;            AddListenerDialog(&#10;                onDismiss = { showAddDialog = false },&#10;                onConfirm = { guid: String, name: String? -&gt;&#10;                    viewModel.addNewListener(guid, name)&#10;                    showAddDialog = false&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/ui/screens/NotificationHistoryScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/opennotification_client/ui/screens/NotificationHistoryScreen.kt" />
              <option name="originalContent" value="package org.opennotification.opennotification_client.ui.screens&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.shrinkHorizontally&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.pulltorefresh.PullToRefreshBox&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import kotlinx.coroutines.delay&#10;import org.opennotification.opennotification_client.data.models.Notification&#10;import org.opennotification.opennotification_client.viewmodel.MainViewModel&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun NotificationHistoryScreen(&#10;    onBackClick: () -&gt; Unit = {},&#10;    onNavigateToDetail: (Notification) -&gt; Unit = {},&#10;    viewModel: MainViewModel = viewModel()&#10;) {&#10;    val notifications by viewModel.allNotifications.collectAsState(initial = emptyList())&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val dateFormat = remember { SimpleDateFormat(&quot;MM/dd/yyyy HH:mm&quot;, Locale.getDefault()) }&#10;    &#10;    var showDeleteConfirmDialog by remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Notification History&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBackClick) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;&#10;                        )&#10;                    }&#10;                },&#10;                actions = {&#10;                    if (notifications.isNotEmpty()) {&#10;                        IconButton(onClick = { showDeleteConfirmDialog = true }) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Delete,&#10;                                contentDescription = &quot;Delete all notifications&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        PullToRefreshBox(&#10;            isRefreshing = isLoading,&#10;            onRefresh = { /* Refresh logic if needed */ },&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            if (notifications.isEmpty()) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(paddingValues),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;No notifications in history&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(paddingValues),&#10;                    contentPadding = PaddingValues(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    items(&#10;                        items = notifications,&#10;                        key = { it.id }&#10;                    ) { notification -&gt;&#10;                        SwipeToDeleteContainer(&#10;                            item = notification,&#10;                            onDelete = { viewModel.deleteNotification(it) }&#10;                        ) { item -&gt;&#10;                            NotificationItem(&#10;                                notification = item,&#10;                                dateFormat = dateFormat,&#10;                                onClick = { onNavigateToDetail(item) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (showDeleteConfirmDialog) {&#10;            AlertDialog(&#10;                onDismissRequest = { showDeleteConfirmDialog = false },&#10;                title = { Text(&quot;Delete all notifications&quot;) },&#10;                text = { Text(&quot;Are you sure you want to delete all notification history? This action cannot be undone.&quot;) },&#10;                confirmButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            viewModel.deleteAllNotifications()&#10;                            showDeleteConfirmDialog = false&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Delete&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(onClick = { showDeleteConfirmDialog = false }) {&#10;                        Text(&quot;Cancel&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NotificationItem(&#10;    notification: Notification,&#10;    dateFormat: SimpleDateFormat,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable(onClick = onClick),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (notification.isAlert) &#10;                MaterialTheme.colorScheme.errorContainer &#10;            else &#10;                MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = notification.title,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = if (notification.isAlert) &#10;                        MaterialTheme.colorScheme.onErrorContainer &#10;                    else &#10;                        MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = dateFormat.format(Date(notification.timestamp)),&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = if (notification.isAlert) &#10;                        MaterialTheme.colorScheme.onErrorContainer &#10;                    else &#10;                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;            &#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            &#10;            notification.description?.let { description -&gt;&#10;                Text(&#10;                    text = description,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = if (notification.isAlert) &#10;                        MaterialTheme.colorScheme.onErrorContainer &#10;                    else &#10;                        MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun &lt;T&gt; SwipeToDeleteContainer(&#10;    item: T,&#10;    onDelete: (T) -&gt; Unit,&#10;    animationDuration: Int = 500,&#10;    content: @Composable (T) -&gt; Unit&#10;) {&#10;    var isRemoved by remember { mutableStateOf(false) }&#10;    var isDeleted by remember { mutableStateOf(false) }&#10;    &#10;    val dismissState = rememberDismissState(&#10;        confirmValueChange = { dismissValue -&gt;&#10;            if (dismissValue == DismissValue.DismissedToStart) {&#10;                isRemoved = true&#10;                true&#10;            } else {&#10;                false&#10;            }&#10;        }&#10;    )&#10;&#10;    LaunchedEffect(isRemoved) {&#10;        if (isRemoved) {&#10;            delay(animationDuration.toLong())&#10;            onDelete(item)&#10;            isDeleted = true&#10;        }&#10;    }&#10;&#10;    AnimatedVisibility(&#10;        visible = !isDeleted,&#10;        exit = shrinkHorizontally(&#10;            animationSpec = tween(durationMillis = animationDuration),&#10;            shrinkTowards = Alignment.Start&#10;        ) + fadeOut()&#10;    ) {&#10;        SwipeToDismiss(&#10;            state = dismissState,&#10;            background = {&#10;                val color = when (dismissState.dismissDirection) {&#10;                    DismissDirection.StartToEnd -&gt; Color.Transparent&#10;                    DismissDirection.EndToStart -&gt; MaterialTheme.colorScheme.error&#10;                    null -&gt; Color.Transparent&#10;                }&#10;                &#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(color)&#10;                        .padding(horizontal = 20.dp),&#10;                    contentAlignment = Alignment.CenterEnd&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Delete,&#10;                        contentDescription = &quot;Delete&quot;,&#10;                        tint = MaterialTheme.colorScheme.onError&#10;                    )&#10;                }&#10;            },&#10;            dismissContent = { content(item) },&#10;            directions = setOf(DismissDirection.EndToStart)&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun rememberDismissState(&#10;    initialValue: DismissValue = DismissValue.Default,&#10;    confirmValueChange: (DismissValue) -&gt; Boolean = { true }&#10;): DismissState {&#10;    return remember {&#10;        DismissState(&#10;            initialValue = initialValue,&#10;            confirmValueChange = confirmValueChange&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SwipeToDismiss(&#10;    state: DismissState,&#10;    background: @Composable RowScope.() -&gt; Unit,&#10;    dismissContent: @Composable RowScope.() -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    directions: Set&lt;DismissDirection&gt; = setOf(&#10;        DismissDirection.StartToEnd,&#10;        DismissDirection.EndToStart&#10;    )&#10;) {&#10;    val isRtl = false&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            content = background&#10;        )&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .offset(&#10;                    x = when (state.dismissDirection) {&#10;                        DismissDirection.StartToEnd -&gt; {&#10;                            if (state.dismissValue == DismissValue.Default) 0.dp else 20.dp&#10;                        }&#10;                        DismissDirection.EndToStart -&gt; {&#10;                            if (state.dismissValue == DismissValue.Default) 0.dp else (-20).dp&#10;                        }&#10;                        null -&gt; 0.dp&#10;                    }&#10;                )&#10;                .draggable(&#10;                    orientation = Orientation.Horizontal,&#10;                    state = rememberDraggableState { delta -&gt;&#10;                        when {&#10;                            delta &gt; 0 &amp;&amp; DismissDirection.StartToEnd in directions -&gt; {&#10;                                state.dismissDirection = DismissDirection.StartToEnd&#10;                                state.offset = delta&#10;                                if (delta &gt; 200) {&#10;                                    state.dismissValue = DismissValue.DismissedToEnd&#10;                                }&#10;                            }&#10;                            delta &lt; 0 &amp;&amp; DismissDirection.EndToStart in directions -&gt; {&#10;                                state.dismissDirection = DismissDirection.EndToStart&#10;                                state.offset = delta&#10;                                if (delta &lt; -200) {&#10;                                    state.dismissValue = DismissValue.DismissedToStart&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onDragStopped = {&#10;                        if (state.dismissValue != DismissValue.Default) {&#10;                            state.confirmValueChange(state.dismissValue)&#10;                        }&#10;                        state.offset = 0f&#10;                        state.dismissDirection = null&#10;                        state.dismissValue = DismissValue.Default&#10;                    }&#10;                ),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;            content = dismissContent&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;enum class DismissDirection {&#10;    StartToEnd,&#10;    EndToStart&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;enum class DismissValue {&#10;    Default,&#10;    DismissedToEnd,&#10;    DismissedToStart&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;class DismissState(&#10;    val initialValue: DismissValue,&#10;    val confirmValueChange: (DismissValue) -&gt; Boolean&#10;) {&#10;    var dismissValue by mutableStateOf(initialValue)&#10;    var dismissDirection by mutableStateOf&lt;DismissDirection?&gt;(null)&#10;    var offset by mutableStateOf(0f)&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun rememberDraggableState(&#10;    onDelta: (Float) -&gt; Unit&#10;): DraggableState {&#10;    return remember { DraggableState(onDelta) }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;class DraggableState(&#10;    val onDelta: (Float) -&gt; Unit&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;fun Modifier.draggable(&#10;    orientation: Orientation,&#10;    state: DraggableState,&#10;    onDragStopped: () -&gt; Unit&#10;): Modifier {&#10;    return this.clickable { }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;enum class Orientation {&#10;    Horizontal,&#10;    Vertical&#10;}" />
              <option name="updatedContent" value="package org.opennotification.opennotification_client.ui.screens&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.shrinkHorizontally&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.pulltorefresh.PullToRefreshBox&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import kotlinx.coroutines.delay&#10;import org.opennotification.opennotification_client.data.models.Notification&#10;import org.opennotification.opennotification_client.viewmodel.MainViewModel&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun NotificationHistoryScreen(&#10;    onBackClick: () -&gt; Unit = {},&#10;    onNavigateToDetail: (Notification) -&gt; Unit = {},&#10;    viewModel: MainViewModel = viewModel()&#10;) {&#10;    val notifications by viewModel.allNotifications.collectAsState(initial = emptyList())&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val dateFormat = remember { SimpleDateFormat(&quot;MM/dd/yyyy HH:mm&quot;, Locale.getDefault()) }&#10;    &#10;    var showDeleteConfirmDialog by remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Notification History&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBackClick) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;&#10;                        )&#10;                    }&#10;                },&#10;                actions = {&#10;                    if (notifications.isNotEmpty()) {&#10;                        IconButton(onClick = { showDeleteConfirmDialog = true }) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Delete,&#10;                                contentDescription = &quot;Delete all notifications&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        PullToRefreshBox(&#10;            isRefreshing = isLoading,&#10;            onRefresh = { /* Refresh logic if needed */ },&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            if (notifications.isEmpty() &amp;&amp; !isLoading) {&#10;                // Afficher le message uniquement si la liste est vide ET qu'on n'est pas en train de charger&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(paddingValues),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;No notifications in history&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            } else {&#10;                // Toujours afficher la LazyColumn, même si elle est vide pendant le chargement&#10;                LazyColumn(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(paddingValues),&#10;                    contentPadding = PaddingValues(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    items(&#10;                        items = notifications,&#10;                        key = { it.id }&#10;                    ) { notification -&gt;&#10;                        SwipeToDeleteContainer(&#10;                            item = notification,&#10;                            onDelete = { viewModel.deleteNotification(it) }&#10;                        ) { item -&gt;&#10;                            NotificationItem(&#10;                                notification = item,&#10;                                dateFormat = dateFormat,&#10;                                onClick = { onNavigateToDetail(item) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (showDeleteConfirmDialog) {&#10;            AlertDialog(&#10;                onDismissRequest = { showDeleteConfirmDialog = false },&#10;                title = { Text(&quot;Delete all notifications&quot;) },&#10;                text = { Text(&quot;Are you sure you want to delete all notification history? This action cannot be undone.&quot;) },&#10;                confirmButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            viewModel.deleteAllNotifications()&#10;                            showDeleteConfirmDialog = false&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Delete&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(onClick = { showDeleteConfirmDialog = false }) {&#10;                        Text(&quot;Cancel&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NotificationItem(&#10;    notification: Notification,&#10;    dateFormat: SimpleDateFormat,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable(onClick = onClick),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (notification.isAlert) &#10;                MaterialTheme.colorScheme.errorContainer &#10;            else &#10;                MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = notification.title,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = if (notification.isAlert) &#10;                        MaterialTheme.colorScheme.onErrorContainer &#10;                    else &#10;                        MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = dateFormat.format(Date(notification.timestamp)),&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = if (notification.isAlert) &#10;                        MaterialTheme.colorScheme.onErrorContainer &#10;                    else &#10;                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;            &#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            &#10;            notification.description?.let { description -&gt;&#10;                Text(&#10;                    text = description,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = if (notification.isAlert) &#10;                        MaterialTheme.colorScheme.onErrorContainer &#10;                    else &#10;                        MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun &lt;T&gt; SwipeToDeleteContainer(&#10;    item: T,&#10;    onDelete: (T) -&gt; Unit,&#10;    animationDuration: Int = 500,&#10;    content: @Composable (T) -&gt; Unit&#10;) {&#10;    var isRemoved by remember { mutableStateOf(false) }&#10;    var isDeleted by remember { mutableStateOf(false) }&#10;    &#10;    val dismissState = rememberDismissState(&#10;        confirmValueChange = { dismissValue -&gt;&#10;            if (dismissValue == DismissValue.DismissedToStart) {&#10;                isRemoved = true&#10;                true&#10;            } else {&#10;                false&#10;            }&#10;        }&#10;    )&#10;&#10;    LaunchedEffect(isRemoved) {&#10;        if (isRemoved) {&#10;            delay(animationDuration.toLong())&#10;            onDelete(item)&#10;            isDeleted = true&#10;        }&#10;    }&#10;&#10;    AnimatedVisibility(&#10;        visible = !isDeleted,&#10;        exit = shrinkHorizontally(&#10;            animationSpec = tween(durationMillis = animationDuration),&#10;            shrinkTowards = Alignment.Start&#10;        ) + fadeOut()&#10;    ) {&#10;        SwipeToDismiss(&#10;            state = dismissState,&#10;            background = {&#10;                val color = when (dismissState.dismissDirection) {&#10;                    DismissDirection.StartToEnd -&gt; Color.Transparent&#10;                    DismissDirection.EndToStart -&gt; MaterialTheme.colorScheme.error&#10;                    null -&gt; Color.Transparent&#10;                }&#10;                &#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(color)&#10;                        .padding(horizontal = 20.dp),&#10;                    contentAlignment = Alignment.CenterEnd&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Delete,&#10;                        contentDescription = &quot;Delete&quot;,&#10;                        tint = MaterialTheme.colorScheme.onError&#10;                    )&#10;                }&#10;            },&#10;            dismissContent = { content(item) },&#10;            directions = setOf(DismissDirection.EndToStart)&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun rememberDismissState(&#10;    initialValue: DismissValue = DismissValue.Default,&#10;    confirmValueChange: (DismissValue) -&gt; Boolean = { true }&#10;): DismissState {&#10;    return remember {&#10;        DismissState(&#10;            initialValue = initialValue,&#10;            confirmValueChange = confirmValueChange&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SwipeToDismiss(&#10;    state: DismissState,&#10;    background: @Composable RowScope.() -&gt; Unit,&#10;    dismissContent: @Composable RowScope.() -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    directions: Set&lt;DismissDirection&gt; = setOf(&#10;        DismissDirection.StartToEnd,&#10;        DismissDirection.EndToStart&#10;    )&#10;) {&#10;    val isRtl = false&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            content = background&#10;        )&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .offset(&#10;                    x = when (state.dismissDirection) {&#10;                        DismissDirection.StartToEnd -&gt; {&#10;                            if (state.dismissValue == DismissValue.Default) 0.dp else 20.dp&#10;                        }&#10;                        DismissDirection.EndToStart -&gt; {&#10;                            if (state.dismissValue == DismissValue.Default) 0.dp else (-20).dp&#10;                        }&#10;                        null -&gt; 0.dp&#10;                    }&#10;                )&#10;                .draggable(&#10;                    orientation = Orientation.Horizontal,&#10;                    state = rememberDraggableState { delta -&gt;&#10;                        when {&#10;                            delta &gt; 0 &amp;&amp; DismissDirection.StartToEnd in directions -&gt; {&#10;                                state.dismissDirection = DismissDirection.StartToEnd&#10;                                state.offset = delta&#10;                                if (delta &gt; 200) {&#10;                                    state.dismissValue = DismissValue.DismissedToEnd&#10;                                }&#10;                            }&#10;                            delta &lt; 0 &amp;&amp; DismissDirection.EndToStart in directions -&gt; {&#10;                                state.dismissDirection = DismissDirection.EndToStart&#10;                                state.offset = delta&#10;                                if (delta &lt; -200) {&#10;                                    state.dismissValue = DismissValue.DismissedToStart&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onDragStopped = {&#10;                        if (state.dismissValue != DismissValue.Default) {&#10;                            state.confirmValueChange(state.dismissValue)&#10;                        }&#10;                        state.offset = 0f&#10;                        state.dismissDirection = null&#10;                        state.dismissValue = DismissValue.Default&#10;                    }&#10;                ),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;            content = dismissContent&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;enum class DismissDirection {&#10;    StartToEnd,&#10;    EndToStart&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;enum class DismissValue {&#10;    Default,&#10;    DismissedToEnd,&#10;    DismissedToStart&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;class DismissState(&#10;    val initialValue: DismissValue,&#10;    val confirmValueChange: (DismissValue) -&gt; Boolean&#10;) {&#10;    var dismissValue by mutableStateOf(initialValue)&#10;    var dismissDirection by mutableStateOf&lt;DismissDirection?&gt;(null)&#10;    var offset by mutableStateOf(0f)&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun rememberDraggableState(&#10;    onDelta: (Float) -&gt; Unit&#10;): DraggableState {&#10;    return remember { DraggableState(onDelta) }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;class DraggableState(&#10;    val onDelta: (Float) -&gt; Unit&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;fun Modifier.draggable(&#10;    orientation: Orientation,&#10;    state: DraggableState,&#10;    onDragStopped: () -&gt; Unit&#10;): Modifier {&#10;    return this.clickable { }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;enum class Orientation {&#10;    Horizontal,&#10;    Vertical&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>